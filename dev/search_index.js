var documenterSearchIndex = {"docs":
[{"location":"TypeStable.html#Type-stability","page":"Type-stability","title":"Type-stability","text":"","category":"section"},{"location":"TypeStable.html#Introduction","page":"Type-stability","title":"Introduction","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"This text presents type stability, which is one of the important concepts that one needs to understand in order to write high-performance Julia code.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"This text is aimed at Julia users that are familiar with composite types, abstract types, functions, methods and multiple dispatch. At the same time, as little advanced Julia syntax as possible is used, to make the text accessible.","category":"page"},{"location":"TypeStable.html#To-type,-or-not-to-type","page":"Type-stability","title":"To type, or not to type","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The developers of Julia wanted to solve the two-language problem.  They have achieved this and produced a language that \"walks like Python and runs like C\".  Julia \"walks like Python\", because it is not necessary to systematically define the type of every variable that appears in the code.  It \"runs like C\" because it is a compiled language, and produces (or rather, can produce) highly efficient machine code.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Python and MATLAB are examples of interpreted language.  In a pure interpreted language, the type of the variables is computed at run time, at the same time as the value of the variables.  As long as the values of the inputs to the code are known at the top level (in the REPL or the top script), the interpretation infers, step by step the type of the variables, all the way down the call stack. This allows to write functions without specifying types, and this in turn allows to write generic code (for example an iterative solver that works just as well with Float64 and Float32 variables).  The disadvantage is that inferring the type of variables on the fly introduces significant overhead at run time.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"At the other end of the scale C and Fortran are examples of strictly typed compiled languages. Because the source code specifies the type of every variable in the function (both variables in the function interface, and local variables), the compiler can create efficient machine code for each function, just by considering the code of that function alone. The disadvantage is that type declaration takes time to write and clutters the source code, and (unless the language offers \"templates\", as C++ does), it may be necessary to write several methods, identical in all but types of variables, to make an algorithm available to various data types.","category":"page"},{"location":"TypeStable.html#Julia's-approach-to-type-specifications","page":"Type-stability","title":"Julia's approach to type specifications","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia takes the sweet spot in between, not requiring to specify the type of each variable, yet producing fast machine code. The trick is as follows: every time a method is called (so, at run time), with a combination of concrete types of arguments that has not yet been encountered for this method, the compiler quicks in.  A \"concrete type\" is the information returned by typeof() when called on a variable.  One example is Float64.  This is as opposed to an abstract type, like Real, which is a set of concrete types, and includes Float64 and Float32. In the rest of this text \"type\" will refer to \"concrete type\".","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The compiler now has the source code of the method, and the types of all the arguments. The compiler will produce a method instance (or instance, for short), which is machine code for this combination. One interesting implication is that writing strictly typed method interfaces in Julia does not provide any improvement of machine code performance: the compiler takes the type of the arguments from the calling context anyway. A strictly typed interface has the disadvantage of offering no flexibility. A method that only accepts a Vector will not accept other vector-like things like a SubArray (an array view), a Adjoint (a transposed array), a SparseMatrix or a StaticArray, even thought the method probably implements an algorithm that would compile perfectly well for all of these.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"However, providing partial specification of the type of the arguments of a method serves important purposes in Julia:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If a function has several methods, it allows to specify which method should be executed (multiple dispatch). This is where abstract types like Real,  AbstractVector and AbstractVector{<:Real} come into their own.\nIt improves code readability, stating for example \"this method expects some vector of some real numbers - but not a string\".\nIt provides more graceful failures: \"function foo has no method that takes in a string\" is more informative that some esoteric failure down the line when attempting to add two strings.","category":"page"},{"location":"TypeStable.html#What-is-type-stability?","page":"Type-stability","title":"What is type stability?","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If the source code of the method is well written, the source code and the concrete type of all arguments is enough information for the compiler to infer the concrete type of every variable and expression within the method.  The method is then said to be \"typestable\", and the Julia compiler will produce efficient code.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If, for a variety of reasons that will be studied in the following, the type of a local variable cannot be inferred from the types of the arguments, the compiler will produce machine code full of \"if\"s, covering all options of what the type of each variable could be. The loss in performance is often significant, easily by a factor of 10.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If you are yourself able to infer the type of every local variable, and every expression in a method (or script) from the types (not the values) of the arguments or from constants in the code, the function will be typestable.  Actually, as will be seen below, this inference of types is also allowed access to struct declarations, and to the types of the return values of functions called by the function you are studying.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The rest of this text will examine a variety of situations, ranging from obvious to more tricky tricky, in which it is not possible to infer the types of local variables from the types of the arguments, resulting in type instability.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"For this purpose, it will be useful to write down the information available to the compiler.  So for example, if the method","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function add(a::Number,b::Number)\n    c = a+b\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"is called with a of type Float64 and b of type Int32, then we will write the information available to the compiler to create an instance as","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance add(a::Float64,b::Int32)\n    c = a+b\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance is not Julia syntax, it is just a notation introduced in this text to describe an instance.  In such instance description, a concrete type must be associated with every argument.","category":"page"},{"location":"TypeStable.html#If,-then","page":"Type-stability","title":"If, then","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Consider the following method instance","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance largest(a::Float64,b::Int64)\n    if a > b\n        c = a\n    else\n        c = b\n    end\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The variable c will be set to either a or b. c will take the value and the type of either a or b.  The type of c depends on an operation a > b on the values of a and b: the type of c cannot be inferred from the type of arguments alone, and this code is not typestable.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Several approaches might be relevant to prevent type instability.  The simplest is to code largest so that it only accepts two arguments of the same type.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function largest(a::R,b::R) where{R<:Real}\n    if a > b\n        c = a\n    else\n        c = b\n    end\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The method is general, it can result in the generation of method instances like instance largest(a::Float64,b::Float64), instance largest(a::Int64,b::Int64) and many others. It cannot result in the generation of machine code for instance largest(a::Float64,b::Int64) (because R cannot be both Int64 and Float64). If we need to be able to handle variables of different types, yet want type stability, a solution is to use promotion to ensure that c is always of the same type.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function largest(a,b)\n    pa,pb = promote(a,b)\n    if a > b\n        c = pa\n    else\n        c = pb\n    end\n    return c\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"promote is defined so that pa and pb have the same type, and this type is inferred from the types of a and b. For example, for a call instance largest(a::Float64,b::Int64), the types of pa, pb and c will be Float64, to which one can convert a Int64 variable without loss of information (well, mostly).","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Do not allow an if-then construct to return a variable which type depends on the branch taken.","category":"page"},{"location":"TypeStable.html#Method-return-value","page":"Type-stability","title":"Method return value","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"A method foo that would call the above first, not typestable, version of the method instance largest would receive as output a variable of a type that is value dependent: foo itself would not be typestable.  The workaround here is to create typestable methods for largest, as suggested above.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"One example is the method Base.findfirst(A), which given a Vector{Boolean} returns the index of the first true element of the vector.  The catch is that if all the vector's elements are false, the method returns nothing. nothing is of type Nothing, while the index is of type Int64.  Using this method will make the calling method not typestable.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Avoid methods that return variables of value-dependant types.","category":"page"},{"location":"TypeStable.html#Array-of-abstract-element-type","page":"Type-stability","title":"Array of abstract element type","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Consider the following code","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"v = [3.,1,\"Hello world!\"]\nfunction showall(v)\n    for e ∈ v\n        @show e\n    end\nend\nshowall(v)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The above call showall(v) generates a method instance","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance showall(v::Array{Any,1})\n    for e ∈ v\n        @show e\n    end\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The concrete type of e cannot be inferred from Array{Any,1}, because Any is not a concrete type. More specifically, the type of e changes from one iteration to the next: the code is not typestable. If v is of type Array{Any,1}, even if V has elements that are all of the same type, this does not help:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"v = Vector{Any}(undef,3)\nv[1] = 3.\nv[2] = 1.\nv[3] = 3.14\nshowall(v)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"e may have the same type at each iteration, but this type still cannot be inferred from the type Array{Any,1} of the argument.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If we define w = randn(3), w has type Array{Float64,1}.  This is much more informative: every element of w is known to have the same concrete type Float64. Hence the call showall(w) generates a method instance","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance showall(v::Array{Float64,1})\n    for e ∈ v\n        @show e\n    end\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"and the compiler can infer that e is a Float64.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Wherever possible use arrays with a concrete element type.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Sometimes, the use of array with abstract element type is deliberate.  One may really wish to iterate over a heterogeneous collection of elements and apply various methods of the same function to them: we design for dynamic dispatch, and must accept that the process of deciding which method to call takes time.  Two techniques can be used to limit the performance penalty.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The first is the use of a \"function barrier\": The loop over the heterogenous array should contain as little code as possible, ideally only the access to the arrays element, and the call to a method.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"for e ∈ v\n    foo(e)\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"If v contains elements of different type, the loop is not typestable and hence slow. Yet each value of e at each iteration has its unique concrete type, for which an instance of foo will be generated: foo can be made typestable and fast.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The second, a further improvement of the first, is to group elements by concrete type, for example, using a heterogenous arrays of homogeneous arrays.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"vv = [[1.,2.,3.],[1,2]]\nfor v ∈ vv  # outerloop\n    innerloop(v)\nend\nfunction innerloop(v)\n    for e ∈ v\n        foo(e)\n    end\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Here vv is an Array{Any,1}, containing two vectors of different types. vv[1] is a Array{Float64,1} and vv[2] is a Array{Int64,1}. Function innerloop is called twice and two instances are generated","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance innerloop(v::Array{Float64,1})\n    for e ∈ v  # e is Float64\n        foo(e)\n    end\nend\ninstance innerloop(v::Array{Int64,1})\n    for e ∈ v  # e is Int64\n        foo(e)\n    end\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"and in both instances, the type of e is clearly defined: the instances are typestable.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The with this second approach is that the loop for v ∈ vv has few iterations (if the number of types is small compared to the number of elements in each types).","category":"page"},{"location":"TypeStable.html#Structure-of-abstract-field-type","page":"Type-stability","title":"Structure of abstract field type","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"A similar loss of type stability arises when reading data from structures that have a field of abstract type:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct SlowType\n    a\nend\nstruct JustAsBad\n    a::Real\nend\nstruct MuchBetter\n    a::Float64\nend\nfunction show_a(s)\n    @show s.a\nend\nshow_a(SlowType(3.))\nshow_a(JustAsBad(3.))\nshow_a(MuchBetter(3.))","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The first call to show_a generates","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance show_a(s::SlowType)\n    @show s.a # The concrete type of field a of type SlowType cannot be\n              # inferred from the definition of SlowType\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The second call to show_a has the same problem.  The third call generates a typestable instance","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance show_a(s::Better)\n    @show s.a # That's a Float64\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"It is often interesting to create structures with fields that can have various types. A classic example is Julia's Complex type, which can have real and imaginary components which are either both Float64, both Float32 or other more exotic choices. This can be done without losing type stability by using parametric types:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct FlexibleAndFast{R}\n    a::R\nend\nshow_a(FlexibleAndFast(3.))\nshow_a(FlexibleAndFast(3 ))","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The above calls generate two typestable instances of show_a","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance show_a(s::FlexibleAndFast{Float64})\n    @show s.a # That's a Float64\nend\ninstance show_a(s::FlexibleAndFast{Int64})\n    @show s.a # That's an Int64\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Always use struct with fields of concrete types.  Use parametric structure where necessary.","category":"page"},{"location":"TypeStable.html#A-note-on-constructors-for-parametric-types","page":"Type-stability","title":"A note on constructors for parametric types","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Consider a struct definition without inner constructor:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct MyType{A,B}\n    a::A\n    b::B\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia will automatically generate a constructor method with signature","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType{A,B}(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia will also produce another method with signature","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"because for MyType, it is possible to infer all type parameters from the types of the inputs to the constructor. Other constructors like","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType{A}(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"have to be defined explicitly (how should the compiler decide whether to interpret a single type-parameter input as A or B...).","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Consider another example:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct MyType{A,B,C}\n    a::A\n    b::B\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia will automatically generate a constructor method with signature","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType{A,B,C}(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"but will not generate other methods.  A method like","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"MyType{C}(a::A,b::B)","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"would have to be defined explicitly.","category":"page"},{"location":"TypeStable.html#StaticArrays","page":"Type-stability","title":"StaticArrays","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Julia Arrays are an example of parametric type, where the parameters are the type of elements, and the dimension (the number of indices). Importantly, the size of the array is not part of the type, it is a part of the value of the array.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The package StaticArrays.jl provides the type StaticArray, useful for avoiding another performance problem: garbage collection that follows the allocation of Arrays on the heap. This is because StaticArray are allocated on the stack, simplifying runtime memory management.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"using StaticArrays\nSA = SVector{3,Float64}([1.,2.,3.])\nSA = SVector(1.,2.,3.)\nSA = SVector([1.,2.,3.])","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The first call to SVector is typestable: all the information needed to infer the type of SA is provided in curly braces. The second call is typestable too, because the compiler can deduce the same information from the type and number of inputs. The third call is problematic: while the type of the elements of SA can be inferred by the compiler, the length of [1.,2.,3.] is part of this array's value, not type. The type of SA has a parameter that depends on the value (the size) of the argument passed to the constructor.  Not only does this generate an instance of the constructor that is not type stable, but the non-inferable type of SA \"contaminates\" the calling code with type instability.","category":"page"},{"location":"TypeStable.html#Val","page":"Type-stability","title":"Val","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"What if we want to write a function that takes an Vector as an input, processes it (for example just keeps it as it is), and returns a SVector of the same shape. Of course we want this function to be general and not be limited to a given array size and we want this function to be typestable, for good performance.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"First attempt:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function static(v::Vector)\n    return SVector{length(v),eltype(v)}(v)\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"This function is not typestable. It constructs a variable of type StaticArray{(3,),Float64}, where 3 is obtained as the length of v, and the length is part of the value of an Array.  Value-to-type alarm!","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"One possible solution is to use Val. Let us say that static is called by a function foo within which the length of v can be inferred at compile time.  We could create the following code","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"function static(v,::Val{L}) where{L}\n    return SVector{L,Float64}(v)\nend\nfunction foo()\n    Val3 = Val(3)\n    Val4 = Val(4)\n    @show static([1.,2.,3.]   ,Val3)\n    @show static([1.,2.,3.,4.],Val4)\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The call Val(3) generates a variable, of type Val{3}. Clearly, Val as a function is not typestable, since it creates a variable of a type depending on the value of its argument.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"However, function foo is typestable.  This may come as a surprise, but two things conspire to allow this:","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The source code of foo explicitly mentions the constants 3 and 4, and the compiler has access to it.\nThe compiler is greedy - it evaluates at compile time whenever possible.  Hence the call Val(3) is evaluated during compilation, and Val3 is known to the compiler to be a a value-empty variable of type Val{3}.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"In foo, the method static is called twice, leading to the generation of two typestable instances","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"instance static(v,::Val{3})\n    return SVector{3,Float64}(v)\nend\ninstance static(v,::Val{4})\n    return SVector{4,Float64}(v)\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"What if the length of the vectors is not defined as a constant in foo?  If this length is the result of some computation, the call to Val with not be typestable. If foo is high enough in the call hierarchy, and outside any time-critical loop, this is not an issue: only foo will not be typestable, but functions that it calls can still be typestable (cf. the function barrier pattern).","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Val allows to move type instability up the call hierarchy, or eliminate it altogether.","category":"page"},{"location":"TypeStable.html#Functions","page":"Type-stability","title":"Functions","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The type Function is an abstract datatype, and every function in Julia has its own type.  Here we refer not to the type of the variables returned by the function, but to the function being a variable in itself.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The implication is that if we have a scalar-valued function energy that takes a function signal as an input, and computes the energy of the signal over some interval, then a new instance of energy will be compiled every time it is called with an new argument signal.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"This also has implications on how to store functions in a struct. This is not typestable","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct MyType\n    foo::Function\nend","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"but this is","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"struct MyType{Tfoo}\n    foo::Tfoo\nend","category":"page"},{"location":"TypeStable.html#@code_warntype","page":"Type-stability","title":"@code_warntype","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"One important tool to check that an instance is typestable is the macro @code_warntype. For example","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"v = randn(3)\n@code_warntype Val(length(v))\n@code_warntype static(v,Val(length(v)))","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"The first invocation of @code_warntype outputs a semi-compiled code, and highlights some of the types in red: the call Val(3) is not typestable. The second invocation of @code_warntype produces an output in which all types are highlighted in blue: the call to static is typestable.  Note that @code_warntype only analyses the compilation of the outermost function static - given the arguments v and Val(length(v)).","category":"page"},{"location":"TypeStable.html#Profile.jl","page":"Type-stability","title":"Profile.jl","text":"","category":"section"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Profile.jl and ProfileView.jl together provide a \"flame graph\", a graphical representation of where processor time goes, in which code that is not typestable is highlighted. Output from the profiler often shows how type instability propagates: a single variable that is not typestable makes \"anything it touches\" type unstable.","category":"page"},{"location":"TypeStable.html","page":"Type-stability","title":"Type-stability","text":"Particularly useful, one can click on a function, and then type warntype_last() in the REPL to get to see a @code_warntype output for that function.","category":"page"},{"location":"Theory.html#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"Theory.html#Classes-of-degrees-of-freedom","page":"Theory","title":"Classes of degrees of freedom","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Muscade introduces 3 classes of degrees of freedom (dofs). ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Xdofs are the dofs normaly encountered in normal \"forward\" FEM analysis.  They provide a discrete representation of the response of the system. There is a one-to-one relation (a \"duality\") between the Xdofs X and the residuals R, which are the discretized form of he differential equations we seek to solve. In forward FEM, we seek to solve a problem of the form","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"forall t R(X(t)t)=0","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Udofs are additional dofs that can be used to represent additional loads on the system. Like Xdofs, Udofs are time-dependant. Unlike Xdofs, there str no residuald (no new equations) corresponding to them.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Adofs are additional dofs that can be used to parameterise the model. Adofs are not time-dependant,and there are no residuals corresponing to them.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Equilibrium now requires","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"forall t R(X(t)U(t)At)=0","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"which is ill-posed (unknowns U and A have been added, but there are no new equations).","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"To simplify the presentations in the following, we drop time t from the notations.  This can be interpreted in two ways:","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"We are looking at a problem at a single instant (static).\nWe are solving an evolution problem (dynamic), and X and U are now vectors-valued functions of time, and Rrepresents a vector of ordinary differential equations (over time). ","category":"page"},{"location":"Theory.html#Target-function","page":"Theory","title":"Target function","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"To make the problem well-posed again, we introduce a target function Q(XUA).  We then seek to make Q extremal (finding a local minimum, maximum), under the constraint R(XUA)=0. Depending on the relevant application, Q can represent different concepts.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In design optimisation, one can associate a monetary value to A (building stronger costs more money), and to X (some system responses, including failure, would cost money). The objective is to find the design with the lowest associated cost.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In an load estimation problem where part of the response is measured, we wish to find the most probable unknown load U (large loads are not likely) and response (a computed response X that drasticaly disagrees with the actual measurements is not likely) - under the constraint that load and response verify equilibrium.  In this case, we minimize the surprisal s = -log(P) instead of maximizing P.  Making probabilities or surprisal extremal is equivalent.   However, since probabilities multiply (the joint probability density of independant variables is equal to the product of the marginal probability densities), the corresponding surprisals add, which fits into the system of having elements add contribution to the system of equations to be solved. Further, the surprisals are typicaly numericaly \"kinder\".","category":"page"},{"location":"Theory.html#Lagrangian","page":"Theory","title":"Lagrangian","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Making Q extremal under the constraint R(XUA)=0 is equivalent to finding an extremal (a saddle point) of the Lagrangian L(LambdaXUA) (not to be confused with the potential in Lagrangian mechanics)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"L(LambdaXUA) = Q(XUA) + R(XUA) cdot Lambda","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"where Λ are Lagrange multipliers.  There is again a one-to-one correspondance between Λdofs and residuals, and this between Λdofs and Xdofs.  One result of this correspondance is that when implmenting a new element, the method doflist does not list the Λdofs (this would otherwise just have been a compulsory repetition of the list of Xdofs). ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"For evolution problems, the dot product R(XUA) cdot Lambda includes an integral over time: the Lagrangian is a functional, and the gradients of L are ordinary (or integral) differential equations (in time), found using Frechet derivatives.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Additional constraints may be introduced. Physical constraints (like contact or boundary conditions) are added by augmenting X and R.  Optimisation constraints may have to be verified at every step (stresses to remain below a critical level, at any time).  They are handled by augmenting U (introducing a Udof Lagrange multiplier).  Optimisation constraints that act only on Adofs (there is a limit to the strength of steel we can order)  are handled by augmenting A.  With the additional constraints, the Lagrangian is of the form","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"beginaligned\nL(LambdaXUA) = Q(XUA)  + leftbeginarraycR(XUA) - g_x(XUA) cdot X_λ  g_x(XUA)endarrayright cdot Λ  + g_u(XUA) cdot U_lambda  + g_a(A) cdot A_lambda \nendaligned","category":"page"},{"location":"Theory.html#Elements","page":"Theory","title":"Elements","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In the original finite element analysis, the elements in a model form a partition of a domain over which differential equations are to be solved. We will call these \"physical elements\".  These elements provide additive contributions to the system of equations R(XUA)=0. Further contributions can come from external loads.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"When doing optimization-FEM in Muscade, the elements provide additive contributions to the Lagrangian scalar L, instead of to the residual vector R. Actualy when creating a new element in Muscade to create an application, one can either implement a contribution to R by implementing a method Muscade.residual for the element, or a contribution to L by implementing Muscade.lagrangian.  For performance, whenever possible (for example when implementing a physical element), prefer Muscade.residual. ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In Muscade, the broad view is taken that anything that contributes to L is an element (even if no part of the domain is actualy associated to the element).  This more general definition of \"elements\" includes a variety of types:","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Physical element, disretizing differential equations over a part of the domain\nKnown external loads on the boundary (non-essential boundary conditions)\nKnown external loads in the domain\nConstrained dofs (essential boundary conditions)\nHolonomic equality and inequality constraints (contact)\nOptimisation constraints (e.g. stresses shal not exceed some limit at any point within part of the domain)\nResponse measurements (surprisal on Xdofs)\nUnknown external loads (surprisal on Udofs)\nDamage (surprisal on Adofs)\nCost of unfavorable response (cost on Xdofs)\nCost of actuators (cost on Udofs)\nCost of building a system (cost on Adofs)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Because \"everything\" is an element, app developers can express a wide range of ideas through Muscade's element API.","category":"page"},{"location":"Theory.html#Solvers","page":"Theory","title":"Solvers","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Solvers in Muscade solve problems of different forms including forward X problems","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"R(X00)=0","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"optimisation XUA problems","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"beginaligned\nnabla_Lambda L(LambdaXUA) = 0 \nnabla_X       L(LambdaXUA) = 0 \nnabla_U       L(LambdaXUA) = 0 \nnabla_A       L(LambdaXUA) = 0\nendaligned","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"as well as corresponding XU and XA problems.","category":"page"},{"location":"Builtin_els.html#Built-in-elements","page":"Built-in elements","title":"Built-in elements","text":"","category":"section"},{"location":"Builtin_els.html","page":"Built-in elements","title":"Built-in elements","text":"Muscade does not physical elements, implementing the solution of some differential equation: this is left to the apps built on Muscade.  Rather, it provide provides some general purpose elements which are practical in some setting in order to introduce loads, costs or  constraints.","category":"page"},{"location":"Builtin_els.html","page":"Built-in elements","title":"Built-in elements","text":"DofLoad adds a time-varying load on a single X-dof.  Elements for more general loads, in particular, consistent loads on element boundaries or domain, or follower loads, need to be provided by apps if required.","category":"page"},{"location":"Builtin_els.html","page":"Built-in elements","title":"Built-in elements","text":"DofCost adds a cost as a function of either X-dofs ,U-dofs (and/or their derivatives), A-dofs and time, or as a function of A-dofs alone. Elements for costs on unknwn distributed load fields (over boundary or domain) must be provided by apps if required.","category":"page"},{"location":"Builtin_els.html","page":"Built-in elements","title":"Built-in elements","text":"SingleDofCost provides a simplified syntax for costs on a single dof.","category":"page"},{"location":"Builtin_els.html","page":"Built-in elements","title":"Built-in elements","text":"ElementCost adds a cost on a combination of one element's dofs and element-results.","category":"page"},{"location":"Builtin_els.html","page":"Built-in elements","title":"Built-in elements","text":"DofConstraint adds a constraint to a combination of values (no time derivatives) of dofs. The constraints can switch over time between equality, inequality and \"off\". Inequality constraints are handled using an interior point method without feasibility step.","category":"page"},{"location":"Builtin_els.html","page":"Built-in elements","title":"Built-in elements","text":"ElementConstraint adds a constraint to a function of internal results from one element. The constraints can switch over time between equality, inequality and \"off\". Inequality constraints are handled using an interior point method without feasibility step.","category":"page"},{"location":"Builtin_els.html","page":"Built-in elements","title":"Built-in elements","text":"Hold provides a simplified syntax to set a single X-dof to zero.","category":"page"},{"location":"Builtin_els.html","page":"Built-in elements","title":"Built-in elements","text":"QuickFix allows to rapidly create a simple element. Apps should not use this.","category":"page"},{"location":"Builtin_sol.html#Built-in-solvers","page":"Built-in solvers","title":"Built-in solvers","text":"","category":"section"},{"location":"Builtin_sol.html#StaticX-solver","page":"Built-in solvers","title":"StaticX solver","text":"","category":"section"},{"location":"Builtin_sol.html","page":"Built-in solvers","title":"Built-in solvers","text":"warning: Warning\nAt this time, the handling of element-memory (see Creating an element) is not implemented.","category":"page"},{"location":"Builtin_sol.html","page":"Built-in solvers","title":"Built-in solvers","text":"StaticX is a non-linear, static, explicit solver for \"normal\" FEM (not optimisation-FEM):  At a succession of times t, it will solve R(X(t)t)=0 (see Theory).","category":"page"},{"location":"Builtin_sol.html","page":"Built-in solvers","title":"Built-in solvers","text":"StaticX can be applied to models that have U and A-dofs. This is handled as follows: One input to StaticX is a State, which can come from initialize! or from the output of another solver. StaticX will keep the U- and A-dofs to the value in the input State. initialize! sets all dofs to zero, so when StaticX is given a State produced by initialize! the analysis starts with X-dofs equal to zero, and U- and A-dofs are kept zero throughout the analysis. ","category":"page"},{"location":"Builtin_sol.html","page":"Built-in solvers","title":"Built-in solvers","text":"StaticX handles inequality constraints using a simplified interior point method, without a feasibility step. This works (reasonnably) well in concert with the built-in DofConstraint element.","category":"page"},{"location":"Builtin_sol.html","page":"Built-in solvers","title":"Built-in solvers","text":"See StaticX.","category":"page"},{"location":"Builtin_sol.html#StaticXUA-solver","page":"Built-in solvers","title":"StaticXUA solver","text":"","category":"section"},{"location":"Builtin_sol.html","page":"Built-in solvers","title":"Built-in solvers","text":"warning: Warning\nAt this time, the handling of element-memory (see Creating an element) is not implemented.","category":"page"},{"location":"Builtin_sol.html","page":"Built-in solvers","title":"Built-in solvers","text":"StaticXUA is a non-linear, static, optimisation-FEM solver, with load and model parameter identification. Given a vector of static equilibrium configurations, obtained for example using StaticX, on a model with costs (and possibly constraints) on U- and A-dofs, the solver will determine response (X-dofs) and unknown loads for each step (Udofs) as well as model parameters for the whole history (Adofs).","category":"page"},{"location":"Builtin_sol.html","page":"Built-in solvers","title":"Built-in solvers","text":"The solvers handles inequality constraints in the same way as StaticX.","category":"page"},{"location":"Builtin_sol.html","page":"Built-in solvers","title":"Built-in solvers","text":"See StaticXUA.","category":"page"},{"location":"Memory.html#Memory-management","page":"Memory management","title":"Memory management","text":"","category":"section"},{"location":"Memory.html#Introduction","page":"Memory management","title":"Introduction","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Mutable structs, arguments passes by value to functions, garbage collection, variable names as tags. A variety of concept in Julia become easier to understand by considering how Julia manages memory, and how this affect performance.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"In line with programming languages of the past decades, Julia uses two approaches to store variables, namely the heap, and the stack. Julia's designer made a few important choices on how they use heap and stack, and these strongly shape how we use the language, in particular when writing high-performance code.","category":"page"},{"location":"Memory.html#The-heap","page":"Memory management","title":"The heap","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The heap is a swath of memory made available to a program.  When a variable is allocated, a preferably contiguous amount of available memory of the right size is found on the heap, and its adress (a pointer) is returned.  Values within that segment of memory can be written to or read, and the variable is deallocated when it is no longer in use.  ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"This is very flexible, but this flexibilty comes at a cost: To allocate a variable one must find available memory, thus there must be a heap-ledger describing what memory is available. Browsing the heap-ledger takes time.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Early in the execution of a program, the heap is unused, and finding space for new variables is easy.  But as variables are allocated and deallocated in arbitrary order, large contiguous area of free memory become rarer: the heap is fragmented, and there might be a need to swap things around (defragmentation).","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Further, language designers must make a choice.  Option one is to let the programmer explicitely deallocate a variable when it is no longer needed.  Unfortunately, bugs in which a variable is not deallocate easily occur. If this happens in some loop, memory is allocated but not deallocated (a memory leak) and these bugs are nasty to track down.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The safer option 2, adopted by Julia, is to automaticaly deallocate memory on the heap when nothing anymore points to it.  That implies that there must be a pointer-ledger of all pointers into the heap, an the language must periodicaly go through the pointer-ledger to find orphaned heap-memory, update the heap-ledger, and possibly defragment the heap (move the variables in order to create large contiguous unallocated memory).  This process is called garbage collection.  While invisible to the programmer, the user sees it: it takes time.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"When a profiler reports the number of allocations, it actualy refers to allocation on the heap, not counting variables created on the stack.","category":"page"},{"location":"Memory.html#The-stack","page":"Memory management","title":"The stack","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The stack is a limited amount of memory managed on a \"last in first out\" basis: as a picture, the stack is vertical and when the stack start empty, the stack pointer points tot he base of the stack. If a new variable needs to be stored, it is added to the top of the stack and the pointer is updated. When the variable no longer needs to be stored, the pointer is just updated back to its previous value (pop the stack).","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The mechanism for creating or destroying a variable is simple, and thus extremely fast.  The drawback of course is that variables are destroyed in reverse order of their creation, which is not always convenient.  However this works perfectly for: ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"input arguments to a function, in languages where these are passed by values, and\nlocal variables for the function.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"All these variables are created when entering the function, and destroyed when leaving it.  The (memory) stack thus fills as the code goes deeper into the call stack.  Recursions gone beserk typicaly result in a (memory) stack overflow.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"That, at least, is how things looked like in the late pre-internet age.  Since then, CPUs have been equipped with a nested system of fast access caches. An outer cache, smaller and fast than RAM, a inner cache, yet smaller and faster, and the CPU's registers are, in a sense, the innermost caches.  It makes sense to store the data currently being processed into one of these inner caches.  But this comes at the cost of complexity to the language and compiler designers: moving data to the cache means to free its original location (which is awkward in the context of a stack). Copying data introduces the classic problem of keeping all copies of the data up to date.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Thus the designers of the Julia language made one important choice: once a variable on the stack has been assigned a value, that value can never be changed.  The variable is said to be immutable. This allows Julia copy any part of the stack to the CPU caches to optimize performance, without worrying about out-of-date copies. \"Immutables are easier to reason about\" says the doc: this may not be true when learning Julia, but applies when writing the compiler. ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Now we see why variable names in Julia are best viualised as tags on a value (you copy the tag if you copy the value, and there can be multiple tags for the same value) as opposed to the parable of a variable as a box in which you can store different value (valid in other languages).","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Julia's designers made another important choice: the size of all variables stored the stack must be known at compile time. This drasticaly simplifies the process of creating or destroying space on the stack when entering a function: just increment or decrement to stack pointer by a value determined for the function (actualy the method instance) at compile time.  Accessing a local variable from inside the function is likewise very fast: add a compile-time constant to the stack pointer, and that's were your data is.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"As we will see, the fact that variables must be ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Immutable\nOf size known at compile time","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"significantly affects how one programs \"on the stack\" in Julia.","category":"page"},{"location":"Memory.html#An-Array","page":"Memory management","title":"An Array","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"In Julia, an Array{2,Float64} is \"copied\", for example by passing it as an argument to a function. What happens?","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"The array comes in several parts","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Heap-memory enough to store all the values in the array, in column major order. \nA smaller amount of heap-memory containing.  a.  the sizes of the first and second indices of the array.  b.  a pointer to the storage 1. of the values.\nOn the stack, a pointer to 2.\nMachine code that is written under the assumption that this array has two indices, that the size of an array element is 64 bits, that array elements can be copied directly to the CPU register for algebraic operations, etc.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"When the array is passed to a function, only 3., the pointer is actually passed to the function, as a copy placed at the right spot on the stack.  Being on the stack, the pointer is immutable: the function cannot reallocate 2. (as then the pointer to 2. would change value, pointing to a new spot on th heap). But one can change the content of the array, and its sizes (push!). Upon return from the function, the caller still has the pointer to a place on same spot on the heap: any change made by the function to values inside the array is visible by the caller.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"If function overwrites the array as a whole however, the interpretation is different","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"function foo(a)\n    a = [0,0]\nend\nA = [1,2]\nfoo(A)\n@show A\n\n2-element Vector{Int64}:\n 1\n 2","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Here foo was given a pointer to an array. By writing a =, foo discards its knowledge of the pointer, and uses the same tag-name to refer to a new spot of memory on the heap containing a pair of zeros.","category":"page"},{"location":"Memory.html#Strategies-for-performance","page":"Memory management","title":"Strategies for performance","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Allocating and deallocating memory on the heap takes time.  The amount of time for each allocation is tiny, but an ocean is just many drops. The time required is not proportional to the amount of memory allocated, but to the amount of individual allocations made.  So let us consider as an example a function inside of a hot loop, that needs internal memory for its local computations, and to return the results it produces.  For the function to be fast it must not allocate/deallocate memory on the heap. Two different strategies can be used to this effect, which we could call \"procedural\" and \"functional\".","category":"page"},{"location":"Memory.html#Procedural-strategy","page":"Memory management","title":"Procedural strategy","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"In the procedural strategy, memory (say Arrays) is preallocated \"once and for all\" on the heap, and passed to the function: arrays or slices of arrays are passed to the function.  The function uses this as work arrays and/or to return outputs: it is said to work \"in place\".  In that way there is one (or several) allocation[s] before the hot loop, and many calls to the function.  In Julia, the naming convention for functions that thus modify their input arguments is to end the function name with !.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"function double!(a)\n    for i∈eachindex(a)\n        a[i] *= 2\n    end\nend\n\na = randn(10)\nfor i = 1:10   # \"hot\" loop\n    double!(a)\nend","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"This strategy is sometimes difficult to implement:","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"If the function requires some working space, passing arrays to it is a breach of separation of concern (a new algorithm might require less, or more memory).\nThe return type of some functions might be hard to predict: even for type-stable functions, evaluating the types of an algorithm's output given the types of its inputs is sometimes best left to the compiler.\nAlgebraic operations, for example, are built into larger expression. In an implementation of *, to be used in a*b+c, operating in place is not an option (see however syntaxes like d .= a.*b.+c that are operating in place).","category":"page"},{"location":"Memory.html#Functional-strategy","page":"Memory management","title":"Functional strategy","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"In the functional strategy, the function creates new variables, both for intermediate results and for return value[s].  For performance, these variables are created on the stack, and must thus be immutable and of size known at compile time. ","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"function double(a)\n    b = 2 .*a\n    return b\nend\n\nusing StaticArrays\na = SVector{10}(randn() for i=1:10)\nfor i = 1:10   # \"hot\" loop\n    a = double(a)\nend","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Note that double is called with a SVector.  SVectors' size is a parameter to the type, and is thus known at compile time. SVectors' are immutable (a[2] = 0 will throw an error), and thus SVectors live on the stack. If double was called with a Vector (which size is part of the value, and which is mutable), the operation b = 2 .*a would result in an allocation.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"This strategy may also be difficult to implement:","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"If many array sizes may be used (leading to the compilation of many method instances).\nIf array sizes depend on input values, using types in which size is part of the type leads to type-unstable code.\nIf large arrays are used, compile times will become excessively high.","category":"page"},{"location":"Memory.html#Working-with-immutables","page":"Memory management","title":"Working with immutables","text":"","category":"section"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"SArrays, ntuples and NamedTuples are useful immutable datastructures.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"If a for example an SArray can not be modified after it is created, how can we fill it with values?  Julia provides two syntaxs to do this, comprehensions and do-loops.  A comprehension looks like this:","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"using StaticArrays\n\nconst N=3 \nf(i) = i^2\n\na = SVector{N}(f(i) for i=1:N)","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"Importantly, N must be a compile-time constant.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"A do-loop allows more complicated operations. We assume that the function material returns a StaticArray σ and a variable χgp of type difficult to predict. The do-loop creates the ntuple accum, which is then unpacked (using comprehensions) to sum the σ values into r and stack the χgp values into χ.","category":"page"},{"location":"Memory.html","page":"Memory management","title":"Memory management","text":"function residual(x,y)\n    ngp   = 4\n    accum = ntuple(ngp) do igp\n        z = x[igp] + y[igp]\n        σ, χgp = material(z)\n        (σ=σ, χ=χgp) \n    end # do igp\n    r = sum(        accum[igp].σ for igp=1:ngp)\n    χ = NTuple{ngp}(accum[igp].χ for igp=1:ngp)\n    return r,χ\nend ","category":"page"},{"location":"Solvers.html#Creating-a-solver","page":"Creating a solver","title":"Creating a solver","text":"","category":"section"},{"location":"Solvers.html","page":"Creating a solver","title":"Creating a solver","text":"TO DO","category":"page"},{"location":"Elements.html#Creating-an-element","page":"Creating an element","title":"Creating an element","text":"","category":"section"},{"location":"Elements.html#Introducton","page":"Creating an element","title":"Introducton","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"New element types, providing new element formulations or adressing new domains in physics are implemented by implementing a datatype and methods for function defined by Muscade: ","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"A constructor which is called when the user adds an element to the model.\nMuscade.doflist specifies the degrees of freedom (dofs) of the element.\nMuscade.residual takes element dofs as input and returns the element's additive contribution to a non-linear system of equations to be solved (a residual aka. a right hand side),\nMuscade.lagrangian takes element dofs as input and returns the element's additive contribution to a function to be extremized (Lagrangian aka. cost function, surprisal...)","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Each element must implement a constructor following a format specified by Muscade, as well as Muscade.doflist.  Each element must also implement either Muscade.lagrangian or Muscade.residual, depending on what is more natural.","category":"page"},{"location":"Elements.html#DataType","page":"Creating an element","title":"DataType","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"For a new element type MyELement, the datatype is defined as","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"struct MyElement <: AbstractElement\n    ...\nend","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"MyElement must be a subtype of AbstractElement.","category":"page"},{"location":"Elements.html#Constructor","page":"Creating an element","title":"Constructor","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The element must provide a constructor of the form","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"function MyElement(nod::Vector{Node};kwargs...)\n    ...\n    return eleobj\nend","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"which will then call the default constructor provided by Julia.  ","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"nod can be used to access the coordinates of the nodes:","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"x = nod[inod].coord[icoord]","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"where inod is the element-node number and icoord the index into a vector of coordinates. coord is  provided by the user when adding a Node to the Model. Muscade has no opinion about, and provides no check of, the length of coord provided by the user. In this way elements can define what coordinate system (how many coordinates, and their interpretation) is to be used.  Coordinate systems can even differ from one node to the next. See also coord.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"kwargs... is any number of named arguments, typicaly defining the material properties of the element.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The user does not call the above-defined element directly.  Instead, an element is added to the model by a call of the form","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"e1 = addelement!(model,MyElement,nodid,kwargs...)","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"See addelement!.","category":"page"},{"location":"Elements.html#Muscade.doflist","page":"Creating an element","title":"Muscade.doflist","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The element must provide a method of the form","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"function Muscade.doflist(::Type{MyElement})\n    return (inod =(...),\n            class=(...),\n            field=(...))\nend","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The syntax ::Type{MyElement} is because doflist will be called by Muscade with a DataType (the type MyElement). The function name must begin with Muscade. to make it possible to overload a function defined in the module Muscade. ","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The return value of the function is a NamedTuple with the fields inod, class and field. ","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"inod  is a NTuple of Int64: for each dof, its element-node number. \nclass is a NTuple of Symbol: for each dof, its class (must be :X, :U or :A).\nfield is a NTuple of Symbol: for each dof, its field.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Importantly, doflist does not mention dofs of class :Λ: if the element implements lagrangian, there is automaticaly a one-to-one correspondance between Λ-dofs and X-dofs.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"For example (using Julia's syntax for one-liner functions):","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Muscade.doflist( ::Type{Turbine}) = (inod =(1   ,1   ,2        ,2        ),\n                                     class=(:X  ,:X  ,:A       ,:A       ),\n                                     field=(:tx1,:tx2,:Δseadrag,:Δskydrag))","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"See doflist.","category":"page"},{"location":"Elements.html#Muscade.lagrangian","page":"Creating an element","title":"Muscade.lagrangian","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Elements that implement a cost on the degrees of freedom must implement a method of the form","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"See lagrangian for the list of arguments and outputs.","category":"page"},{"location":"Elements.html#Automatic-differentiation","page":"Creating an element","title":"Automatic differentiation","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The gradients and Hessians of L do not need to be implemented, because Muscade uses automatic  differentiation. Because of this, it is important not to over-specify the inputs.  For example,  implementing a function header with","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"@espy function Muscade.lagrangian(o::MyElement,Λ::Vector{Float64},X,U,A,t,χ,χcv,SP,dbg)\n#                                               ____bad_idea____","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"would cause a MethodError, because Muscade will attempt to call with a SVector instead of Vector, and a special datatype supporting automatic diffeentiation instead of Float64.","category":"page"},{"location":"Elements.html#Extraction-of-element-results","page":"Creating an element","title":"Extraction of element-results","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The function definition must be anotated with the macro call @espy.  Variables within the body of lagrange, which the user may want to obtain must be anotated with ☼ (by typing \\sun they pressing TAB) at the place where they are calculated. An example would be ","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"    ☼σ = E*ε","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The macro will generate two versions of lagrange.  One in which the anotations ☼ are taken away, which is used to solve the numerical problem.  Another with additional input and output variables, and code inserted into the body of the function to extract results wanted by the user.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"See @espy for a complete guide on code anotations. ","category":"page"},{"location":"Elements.html#Muscade.residual","page":"Creating an element","title":"Muscade.residual","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Elements that implement \"physics\" will typicaly implement residual (they could implement the same using lagrangian, but the resulting code would be less performant).","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The interface is mostly the same as for lagrangian with the differences that","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"residual returns a vector R\nthere is no argument Λ","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"@espy function Muscade.residual(o::MyElement,X,U,A,t,χ,χcv,SP,dbg) \n    ...\n    return R,noχ,noFB\nend","category":"page"},{"location":"Elements.html#Immutables-and-Gauss-quadrature","page":"Creating an element","title":"Immutables and Gauss quadrature","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"residual is called many times and it is critical to obtain high performance. Thus, allocating the vector R on the heap  within the function must be avoided. A design option would be to have Muscade pass a preallocated vector R and have  residual mutate its argument.  For \"forward\" automatic differentiation, it can be difficult to predict the element type of R, and other techniques of automatic differentiaton do not accomodate mutations.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"For this reason, residual and lagrange must be writen in a functional style, using only immutable variables, and in particular immutable arrays.  This can be done using StaticArrays.jl (tested) or Tensorial.jl (not tested with Muscade), and generaly results in very readable code that directly expresses concepts of linear algebra.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"One difficulty arises with Gauss quadrature.  Typical implementations would rely on setting R to zero, then adding the  contributions from quadrature points to R within a for loop over the Gauss points.  The pseudo code (not valid in Muscade):","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"R .= 0\nfor igp = 1:ngp\n    F = ...\n    Σ = ...\n    R += F ∘ Σ ∘ ∇N * dV\nend","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"shows that R is mutated. A pseudocode in immutable style would be","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"@espy function residual(x,χ)\n    t = ntuple(ngp) do igp\n        ☼F = ...\n        ☼Σ = ...\n        r = F ∘ Σ ∘ ∇N * dV\n        @named(χ,r)\n    end\n    χ = ntuple(igp->t[igp].χ,ngp)\n    R = sum(   igp->t[igp].r,ngp)\n    return R,χ\nend","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"r are the contributions to R at each quadrature point.  The operation t = ntuple ... returns a datastructure t such that t[igp].χ are the memory variable and `t[igp].r the contribution to the residual from the igp-th quadrature point. This is because","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"    t = ntuple(ngp) do igp\n        expr(igp)\n    end    ","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"is equivalent to ","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"    t = ntuple(expr for igp=1:ngp)","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"which returns","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"    t = (expr(1),expr(2),...,expr(ngp))","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"where the value of expr is that of its last line @named(χ,r) which is a macro provided by Muscade that inserts the code (χ=χ,r=r).","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"The code ","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"    χ = ntuple(igp->t[igp].χ,ngp)\n    R = sum(   igp->t[igp].r,ngp)","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"gathers the memories of all quadrature points into a Tuple and adds together the contributions r into the residual R.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"See residual.","category":"page"},{"location":"Elements.html#Help-functions","page":"Creating an element","title":"Help functions","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Muscade provides functions and constants to make it easier to comply with the API:","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Element constructors can use function coord to extract the coordinates fron the Vector{Node} they get as first argument.\nresidual and lagrangian must use ∂0, ∂1 and ∂2 when extracting the zeroth, first and second time derivatives from arguments X and U.\nConstants noχ and noFB (which have value nothing) can be used by elements that do not have memory or no feedback to the solving procedure.","category":"page"},{"location":"Elements.html#Performance","page":"Creating an element","title":"Performance","text":"","category":"section"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"For a given element formulation, the performance of residual and lagrangian can vary with a factor up to 100 between a good and a bad implementation.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Type stable code allows the compiler to know the type of every variable in a function given the type of its parameters. Code that is type unstable is significantly slower. See the page on type stability.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Allocation, and the corresponding deallocation of memory on the heap takes time. By contrast, allocation and deallocation on the stack is fast.  In Julia, only immutable variables can be allocated on the stack. See the page on memory management","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"Automatic differentiation generaly does not affect how residual and lagrangian are writen.  There are two performance-related exceptions to this:","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"If a complex sub function in residual and lagrangian (typicaly a material model or other closure) operates on an array (for example, the strain) that is smaller than the number of degrees of freedom of the system, computing time can be saved by computing the derivative of the output (in the example, the stress) with respect to the input to the subfunction, and then compose the derivatives.\nIterative precedures are sometimes used within residual and lagrangian, a typical example being in plastic material formulations.  There is no need to propagate automatic differentiation through all the iterations - doing so with the result of the iteration provides the same result.","category":"page"},{"location":"Elements.html","page":"Creating an element","title":"Creating an element","text":"See the page on automatic differentiation","category":"page"},{"location":"Adiff.html#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"Adiff.html","page":"Automatic differentiation","title":"Automatic differentiation","text":"TODO","category":"page"},{"location":"Modelling.html#Creating-a-model","page":"Creating a model","title":"Creating a model","text":"","category":"section"},{"location":"Modelling.html#Script-as-input","page":"Creating a model","title":"Script as input","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Muscade being a framework for the development of optimization-FEM applications, it only provides a limited number of generic modeling capabilities, like fixing degrees of freedom (dofs) to describe boundary conditions, introducing holonomic constraints or costs on either dofs, or element-results (see Built-in elements). Muscade does not provide the elements needed to treat any specific application.  Hence to create a model, one will typicaly be using both Muscade and another package that provide a Muscade-based application (app).  The app provides specific elements for domains like continuum mechanics, marine structures, hydrogen diffusion etc.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Input to such an app is provided in the form of a Julia script containing instructions (calls to Muscade, using elements and possibly solvers provided by the app) to define the model, execute analyses, and extract and process analysis results.  This has two advantages: ","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Scripting a series of analyses, or some specific pre or postprocessing is simply done in the same script.  \nApp developpers do not need to write code pertaining to a user interface.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"That said, an app could introduce a GUI that would itself do the calls to Muscade.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Here is a simple example of analysis:","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"using Muscade\nusing StaticArrays\n\nmodel           = Model(:TestModel)\nn1              = addnode!(model,[0.]) \nn2              = addnode!(model,[1.])\ne1              = addelement!(model,Hold,[n1];field=:tx1)\ne2              = addelement!(model,DofLoad,[n2];field=:tx1,value=t->3t)\ne3              = addelement!(model,QuickFix,[n1,n2];inod=(1,2),field=(:tx1,:tx1),\n                              res=(X,X′,X″,t)->12SVector(X[1]-X[2],X[2]-X[1]))\n\ninitialstate    = initialize!(model)\nstate           = solve(StaticX;initialstate,time=[0.,1.],verbose=false)\n\ntx1,_           = getdof(state[2],field=:tx1,nodID=[n2])\nreq             = @request F\neleres          = getresult(state,req,[e2]) \niele,istep      = 1,2\nforce           = eleres[iele,istep].F","category":"page"},{"location":"Modelling.html#Model-definition","page":"Creating a model","title":"Model definition","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"The definition of a model is done in three phases:","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Creating a blank model.\nAdding nodes.\nAdding elements.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"One can actually add nodes to the model after elements have been added.  One can however only add an element to the model after all the nodes of the element have been added to the model.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"Muscade does not provide a mesher. There are some general purposes meshers with Julia API that could be used.","category":"page"},{"location":"Modelling.html#Running-the-analysis","page":"Creating a model","title":"Running the analysis","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"initialize! is used to create an as-meshed state of the system. Typicaly (but this depends on the app), all dofs are set to zero. The resulting variable, here called initialstate contains a pointer to the model.  Once a model is thus initialized, one can no longer add nodes or elements to it.  This is to ensure that a model can not be modified during a sequence of analyses.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"solve is then called with the name of the solver to be used (here StaticX), and any named parameters required by the solver. The return value state is for this solver a vector (over the time steps) of States.","category":"page"},{"location":"Modelling.html#Extracting-results","page":"Creating a model","title":"Extracting results","text":"","category":"section"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"States (returned by initialize! and solve). are variables which contents are private (not part of the API, and subject to change), but can be accessed using functions like getdof and getresult.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"getdof allows to obtain dofs which are directly stored in state, by specifying class, field and node.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"getresult (used in combination with @request) allows to obtain element-results which have been marked as requestable inside the function lagrangian or residual of an element. These element-results are not stored in the State: getresult will call a modified version of lagrangian or residual to obtain the @requested results.","category":"page"},{"location":"Modelling.html","page":"Creating a model","title":"Creating a model","text":"TODO Plotting results","category":"page"},{"location":"reference.html#reference","page":"Reference manual","title":"Reference manual","text":"","category":"section"},{"location":"reference.html#Constants","page":"Reference manual","title":"Constants","text":"","category":"section"},{"location":"reference.html","page":"Reference manual","title":"Reference manual","text":"Modules = [Muscade]\nOrder   = [:constant]","category":"page"},{"location":"reference.html#Muscade.noFB","page":"Reference manual","title":"Muscade.noFB","text":"noFB\n\nA constant, used by elements' residual or lagrangian as their 3rd output if they do provide  any feedback to the solver (for example, on the reduction of the barrier parameter in interior point method).\n\nExample: return L,noχ,noFB\n\nSee also: noFB\n\n\n\n\n\n","category":"constant"},{"location":"reference.html#Muscade.noχ","page":"Reference manual","title":"Muscade.noχ","text":"noχ\n\nA constant, used by elements' residual or lagrangian as their 2nd output if they do not export any material memory (for example, plastic strain).\n\nExample: return L,noχ,noFB\n\nSee also: noFB\n\n\n\n\n\n","category":"constant"},{"location":"reference.html#Muscade.ϵ","page":"Reference manual","title":"Muscade.ϵ","text":"ϵ (\\epsilon)\n\nan alias for Base.eps(𝕣). \n\n\n\n\n\n","category":"constant"},{"location":"reference.html#Muscade.∞","page":"Reference manual","title":"Muscade.∞","text":"∞ (\\infty)\n\nan alias for Base.inf. \n\n\n\n\n\n","category":"constant"},{"location":"reference.html#Types","page":"Reference manual","title":"Types","text":"","category":"section"},{"location":"reference.html","page":"Reference manual","title":"Reference manual","text":"Modules = [Muscade]\nOrder   = [:type]","category":"page"},{"location":"reference.html#Muscade.AbstractElement","page":"Reference manual","title":"Muscade.AbstractElement","text":"AbstractElement\n\nAn abstract data type.  An element type MyElement must be declared as a subtype of AbstractElement.\n\nMyELementmust provide a constructor with interface\n\n`eleobj = MyElement(nod::Vector{Node}; kwargs...)`\n\nSee also: coord, Node, lagrangian    \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.DofConstraint","page":"Reference manual","title":"Muscade.DofConstraint","text":"DofConstraint{λclass,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,\n    afield,λinod,λfield,Tg,Tmode} <: AbstractElement\n\nAn element to apply physical/optimisation equality/inequality constraints on dofs. \n\nThe constraints are holonomic, i.e. they apply to the values, not the time derivatives, of the involved dofs.  This element is very general but not very user-friendly to construct, factory functions are provided for better useability.  The sign convention is that the gap g≥0 and the Lagrange multiplier λ≥0.\n\nThis element can generate three classes of constraints, depending on the input argument λclass.\n\nλclass=:X Physical constraint.  In mechanics, the Lagrange multiplier dof is a   generalized force, dual of the gap. The gap function must be of the form gap(x,t,gargs...).\nλclass=:U Time varying optimisation constraint. For example: find A-parameters so that  at all times, the response does not exceed a given criteria. The gap function must be of the form     gap(x,u,a,t,gargs...).\nλclass=:A Time invariant optimisation constraint. For example: find A-parameters such that  A[1]+A[2]=gargs.somevalue. The gap function must be of the form gap(a,gargs...).\n\nNamed arguments to the constructor\n\nxinod::NTuple{Nx,𝕫}=()       For each X-dof to be constrained, its element-node number.\nxfield::NTuple{Nx,Symbol}=() For each X-dof to be constrained, its field.\nuinod::NTuple{Nu,𝕫}=()       For each U-dof to be constrained, its element-node number.\nufield::NTuple{Nu,Symbol}=() For each U-dof to be constrained, its field.\nainod::NTuple{Na,𝕫}=()       For each A-dof to be constrained, its element-node number.\nafield::NTuple{Na,Symbol}=() For each A-dof to be constrained, its field.\nλinod::𝕫                     The element-node number of the Lagrange multiplier.\nλclass::Symbol               The class (:X,:U or :A) of the Lagrange multiplier.                                 See the explanation above for classes of constraints\nλfield::Symbol               The field of the Lagrange multiplier.\ngₛ::𝕣=1.                      A scale for the gap.\nλₛ::𝕣=1.                      A scale for the Lagrange multiplier.\ngap::Function                The gap function.\ngargs::NTuple                Additional inputs to the gap function.\nmode::Function               where mode(t::ℝ) -> Symbol, with value :equal,                                 :positive or :off at any time. An :off constraint                                 will set the Lagrange multiplier to zero.\n\nExample\n\nusing Muscade\nmodel           = Model(:TestModel)\nn1              = addnode!(model,𝕣[0]) \ne1              = addelement!(model,DofConstraint,[n1],xinod=(1,),xfield=(:t1,),\n                              λinod=1, λclass=:X, λfield=:λ1,gap=(x,t)->x[1]+.1,\n                              mode=positive)\ne2              = addelement!(model,QuickFix  ,[n1],inod=(1,),field=(:t1,),\n                              res=(x,u,a,t)->0.4x.+.08+.5x.^2)\ninitialstate    = initialize!(model)\nstate           = solve(StaticX;initialstate,time=[0.],verbose=false) \nX               = state[1].X[1]\n\nSee also: Hold, ElementConstraint, off, equal, positive\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.DofCost","page":"Reference manual","title":"Muscade.DofCost","text":"DofCost{Class,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,\n    afield,Tcost,Tcostargs} <: AbstractElement\n\nAn element to apply costs on combinations of dofs.  \n\nNamed arguments to the constructor\n\nxinod::NTuple{Nx,𝕫}=()       For each X-dof to enter cost, its element-node number.\nxfield::NTuple{Nx,Symbol}=() For each X-dof to enter cost, its field.\nuinod::NTuple{Nu,𝕫}=()       For each U-dof to enter cost, its element-node number.\nufield::NTuple{Nu,Symbol}=() For each U-dof to enter cost, its field.\nainod::NTuple{Na,𝕫}=()       For each A-dof to enter cost, its element-node number.\nafield::NTuple{Na,Symbol}=() For each A-dof to enter cost, its field.\nclass:Symbol                 :A for cost on A-dofs only, :I (\"instant\") otherwise.\ncost::Function               if class==:I, cost(X,U,A,t,costargs...)→ℝ                                if class==:A, cost(A,costargs...)→ℝ                                 X and U are tuples (derivates of dofs...), and ∂0(X),∂1(X),∂2(X)                                 must be used by cost to access the value and derivatives of X (resp. U) \ncostargs::NTuple\n\nRequestable internal variables\n\ncost, the value of the cost.\n\nExample\n\nele1 = addelement!(model,DofCost,[nod1],xinod=(1,),field=(:tx1,),\n       class=:I,cost=(X,U,A,t)->X[1]^2\n\nSee also: SingleDofCost, ElementCost, addelement!  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.DofLoad","page":"Reference manual","title":"Muscade.DofLoad","text":"DofLoad{Tvalue,Field} <: AbstractElement\n\nAn element to apply a loading term to a single X-dof.  \n\nNamed arguments to the constructor\n\nfield::Symbol.\nvalue::Function, where value(t::ℝ) → ℝ.\n\nRequestable internal variables\n\nF, the value of the load.\n\nExamples\n\nusing Muscade\nmodel = Model(:TestModel)\nnode  = addnode!(model,𝕣[0,0])\ne     = addelement!(model,DofLoad,[node];field=:tx,value=t->3t-1)\n\nSee also: Hold, DofCost  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ElementConstraint","page":"Reference manual","title":"Muscade.ElementConstraint","text":"ElementConstraint{Teleobj,λinod,λfield,Nu,Treq,Tg,Tgargs,Tmode} <: AbstractElement\n\nAn element to apply optimisation equality/inequality constraints on the element-results of  another \"target\" element. The target element must not be added separatly to the model.  Instead, the  ElementType, and the named arguments to the target element are provided as input to the  ElementConstraint constructor.\n\nThis element generates a time varying optimisation constraint. For example: find A-parameters so that    at all times, the element-result von-Mises stress does not exceed a given value. \n\nThe Lagrangian multiplier introduced by this optimisation constraint is of class :U   \n\nNamed arguments to the constructor\n\nλinod::𝕫            The element-node number of the Lagrange multiplier.\nλfield::Symbol      The field of the Lagrange multiplier.\nreq                 A request for element-results to be extracted from the target element, see @request.                       The request is formulated as if adressed directly to the target element (no \"prefixing\" with                        eleres, see \"Requestable internal variables\")\ngₛ::𝕣=1.             A scale for the gap.\nλₛ::𝕣=1.             A scale for the Lagrange multiplier.\ngap                 a gap function gap(eleres,X,U,A,t,gargs...)→ℝ                       X and U are tuples (derivates of dofs...), and ∂0(X),∂1(X),∂2(X)                        must be used by cost to access the value and derivatives of X (resp. U).                       X, U and A are the degrees of freedom of the element ElementType.\ngargs::NTuple       Additional inputs to the gap function. \nmode::Function      where mode(t::ℝ) -> Symbol, with value :equal,                        :positive or :off at any time. An :off constraint                        will set the Lagrange multiplier to zero.\nElementType         The named of the constructor for the relevant element \nelementkwargs       A named tuple containing the named arguments of the ElementType constructor.     \n\nRequestable internal variables\n\nFrom ElementConstraint one can request\n\nλ                   The constraints Lagrange multiplier\ngap                 The constraints gap function\n\nFrom the target element on can request\n\neleres(...)         where ... is the list of requestables from the target element.  It must be \"prefixed\" by                        eleres to prevent possible confusion with variables requestable from ElementConstraint.\n\nδX\n\nExample\n\n@once gap(eleres,X,U,A,t) = eleres.Fh^2\nele1 = addelement!(model,ElementCoonstraint,[nod1];req=@request(Fh),\n                   gap,λinod=1,λfield=:λ,mode=equal, \n                   ElementType=AnchorLine,\n                   elementkwargs=(Δxₘtop=[5.,0,0], xₘbot=[250.,0],L=290., buoyancy=-5e3))\n\nSee also: Hold, DofConstraint, off, equal, positive, @request\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ElementCost","page":"Reference manual","title":"Muscade.ElementCost","text":"ElementCost{Teleobj,Treq,Tcost,Tcostargs} <: AbstractElement\n\nAn element to apply costs on another \"target\" element's dofs and element-results.   The target element must not be added separatly to the model.  Instead, the  ElementType, and the named arguments to the target element are provided as input to the ElementCost constructor.\n\nNamed arguments to the constructor\n\nreq                 A request for element-results to be extracted from the target element, see @request.                       The request is formulated as if adressed directly to the target element (no \"prefixing\" with                        eleres, see \"Requestable internal variables\")\ncost                a cost function cost(eleres,X,U,A,t,costargs...)→ℝ                       X and U are tuples (derivates of dofs...), and ∂0(X),∂1(X),∂2(X)                        must be used by cost to access the value and derivatives of X (resp. U).                       X, U and A are the degrees of freedom of the element ElementType.\ncostargs=(;)        A named tuple of additional arguments to the cost function \nElementType         The named of the constructor for the relevant element \nelementkwargs       A named tuple containing the named arguments of the ElementType constructor.     \n\nRequestable internal variables\n\nFrom ElementConstraint one can request\n\ncost               The value of the cost\n\nFrom the target element once can request\n\neleres(...)        where ... is the list of requestables from the target element.  It must be \"prefixed\" by                       eleres to prevent possible confusion with variables requestable from ElementConstraint.\n\nExample\n\n@once cost(eleres,X,U,A,t) = eleres.Fh^2\nele1 = addelement!(model,ElementCost,[nod1];req=@request(Fh),\n                   cost=cost,ElementType=AnchorLine,\n                   elementkwargs=(Λₘtop=[5.,0,0], xₘbot=[250.,0], L=290., buoyancy=-5e3))\n\nSee also: SingleDofCost, DofCost, @request \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Hold","page":"Reference manual","title":"Muscade.Hold","text":"Hold <: AbstractElement\n\nAn element to set a single X-dof to zero.  \n\nNamed arguments to the constructor\n\nfield::Symbol. The field of the X-dof to constraint.\nλfield::Symbol=Symbol(:λ,field). The field of the Lagrange multiplier.\n\nExample\n\nusing Muscade\nmodel = Model(:TestModel)\nnode  = addnode!(model,𝕣[0,0])\ne     = addelement!(model,Hold,[node];field=:tx)\n\nSee also: DofConstraint, DofLoad, DofCost \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Model","page":"Reference manual","title":"Muscade.Model","text":"model = Model([ID=:my_model])\n\nConstruct a blank model, which will be mutated to create a finite element [optimization] problem.\n\nSee also: addnode!, addelement!, describe, solve  \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Monitor","page":"Reference manual","title":"Muscade.Monitor","text":"Monitor <: AbstractElement\n\nAn element for for monitoring inputs to and outputs from another element, during an analysis.     \n\nInstead of adding the element to be monitored directly into the model, add this element with the element to be monitored as argument.\n\nNamed arguments to the constructor\n\nElementType         The the type of element to be monitored-\ntriggerl            A function that takes dbg as an input and returns a boolean                        (true) to printout.\nelementkwargs       a NamedTuple containing the named arguments of the ElementType constructor.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.Node","page":"Reference manual","title":"Muscade.Node","text":"Node\n\nThe eltype of vectors handed by Muscade as first argument to element constructors.\n\nExample: function SingleDofCost(nod::Vector{Node};class::Symbol, ... )\n\nSee also: coord \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.QuickFix","page":"Reference manual","title":"Muscade.QuickFix","text":"QuickFix <: AbstractElement\n\nAn element for creating simple elements with \"one line\" of code.   Elements thus created have several limitations:\n\nno internal state.\nno initialisation.\nphysical elements with only X-dofs.\nonly R can be espied.\n\nThe element is intended for testing.  Muscade-based applications should not include this in their API. \n\nNamed arguments to the constructor\n\ninod::NTuple{Nx,𝕫}. The element-node numbers of the X-dofs.\nfield::NTuple{Nx,Symbol}. The fields of the X-dofs.\nres::Function, where res(X::ℝ1,X′::ℝ1,X″::ℝ1,t::ℝ) → ℝ1, the residual.\n\nExamples\n\nA one-dimensional linear elastic spring with stiffness 2.\n\nusing Muscade\nmodel = Model(:TestModel)\nnode1  = addnode!(model,𝕣[0])\nnode2  = addnode!(model,𝕣[1])\ne = addelement!(model,QuickFix,[node1,node2];inod=(1,2),field=(:tx1,:tx1),\n                res=(X,X′,X″,t)->Svector{2}(2*(X[1]-X[2]),2*(X[2]-X[1])) )\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.SingleDofCost","page":"Reference manual","title":"Muscade.SingleDofCost","text":"SingleDofCost{Derivative,Class,Field,Tcost} <: AbstractElement\n\nAn element with a single node, for adding a cost to a given dof.  \n\nNamed arguments to the constructor\n\nclass::Symbol, either :X, :U or :A.\nfield::Symbol.\ncost::Function, where cost(x::ℝ,t::ℝ[,costargs...]) → ℝ if class is :X or  :U, and cost(x::ℝ,[,costargs...]) → ℝ if class is :A.\ncostargs::NTuple\nderivative::Int 0, 1 or 2 - which derivative of the dof enters the cost\t    \n\nRequestable internal variables\n\ncost, the value of the cost.\n\nExample\n\nusing Muscade\nmodel = Model(:TestModel)\nnode  = addnode!(model,𝕣[0,0])\ne     = addelement!(model,SingleDofCost,[node];class=:X,field=:tx,\n                    costargs=(3.,),cost=(x,t,three)->(x/three)^2)\n\nSee also: DofCost, ElementCost\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.StaticX","page":"Reference manual","title":"Muscade.StaticX","text":"StaticX\n\nA non-linear static solver for forward (not inverse, optimisation) FEM. The current implementation does not handle element memory. \n\nAn analysis is carried out by a call with the following syntax:\n\ninitialstate    = initialize!(model)\nstate           = solve(StaticX;initialstate=initialstate,time=[0.,1.])\n\nNamed arguments\n\ndbg=(;)           a named tuple to trace the call tree (for debugging)\nverbose=true      set to false to suppress printed output (for testing)\nsilenterror=false set to true to suppress print out of error (for testing) \ninitialstate      a single state - obtained from a call to initialize!, or                      from a previous analysis\ntime              an AbstractVector vector of the times at which to compute                      equilibrium.  While this solver does not account for dynamic                     effect, the model will typicaly describe some loads as time                      dependent. \nmaxiter=50        maximum number of Newton-Raphson iteration at any given step \nmaxΔx=1e-5        convergence criteria: a norm on the scaled X increment \nmaxincrement=∞    convergence criteria: a norm on the scaled residual\nsaveiter=false    set to true so that the output state is a vector describing                      the states of the model at the last iteration (for debugging                      non-convergence) \nγ0=1.             an initial value of the barrier coefficient for the handling of contact                     using an interior point method\nγfac1=0.5         at each iteration, the barrier parameter γ is multiplied \nγfac2=100.        by γfac1*exp(-min(αᵢ)/γfac2)^2), where αᵢ is computed by the i-th                     interior point savvy element as αᵢ=abs(λ-g)/γ                                               \n\nOutput\n\nA vector of length equal to that of time containing the state of the model at each of these steps                       \n\nSee also: solve, StaticXUA, initialize!\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.StaticXUA","page":"Reference manual","title":"Muscade.StaticXUA","text":"StaticXUA\n\nA non-linear static solver for optimisation FEM. The current algorithm does not handle element memory. \n\nAn analysis is carried out by a call with the following syntax:\n\ninitialstate    = initialize!(model)\nstateX          = solve(StaticX  ;initialstate=initialstate,time=[0.,1.])\nstateXUA        = solve(StaticXUA;initialstate=stateX)\n\nNamed arguments\n\ndbg=(;)           a named tuple to trace the call tree (for debugging)\nverbose=true      set to false to suppress printed output (for testing)\nsilenterror=false set to true to suppress print out of error (for testing) \ninitialstate      a vector of states, one for each load case in the optimization problem,                      obtained from one or several previous StaticX analyses\nmaxAiter=50       maximum number of \"outer\" Newton-Raphson iterations over A \nmaxΔa=1e-5        \"outer\" convergence criteria: a norm on the scaled A increment \nmaxLa=∞           \"outer\" convergence criteria: a norm on the scaled La residual\nmaxYiter=0        maximum number of \"inner\" Newton-Raphson iterations over X                      and U for every value of A.  Experience so far is that these inner                     iterations do not increase performance, so the default is \"no inner                      iterations\".   \nmaxΔy=1e-5        \"inner\" convergence criteria: a norm on the scaled Y=[XU] increment \nmaxLy=∞           \"inner\" convergence criteria: a norm on the scaled Ly=[Lx,Lu] residual\nsaveiter=false    set to true so that the output state is a vector (over the Aiter) of                      vectors (over the steps) of States of the model (for debugging                      non-convergence). \nγ0=1.             an initial value of the barrier coefficient for the handling of contact                     using an interior point method\nγfac1=0.5         at each iteration, the barrier parameter γ is multiplied \nγfac2=100.        by γfac1*exp(-min(αᵢ)/γfac2)^2), where αᵢ is computed by the i-th                     interior point savvy element as αᵢ=abs(λ-g)/γ                                               \n\nOutput\n\nA vector of length equal to that of initialstate containing the state of the optimized model at each of these steps.                       \n\nSee also: solve, StaticX \n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.default","page":"Reference manual","title":"Muscade.default","text":"default{:fieldname}(namedtuple,defval)\n\nattempt to get a field fieldname from a NamedTuple. If namedtuple does not have  such a field - or is not a NamedTuple, return defval.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ℕ","page":"Reference manual","title":"Muscade.ℕ","text":"ℕ (\\bbN)\n\nan alias for UInt64. For use in dispatching. ℕ1... ℕ4 are AbstractArrays of dimensions 1 to 4.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ℝ","page":"Reference manual","title":"Muscade.ℝ","text":"ℝ (\\bbR)\n\nan alias for abstract type Real. For use in dispatching. ℝ1... ℝ4 are AbstractArrays of dimensions 1 to 4. ℝ11 is an AbstractVector of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.ℤ","page":"Reference manual","title":"Muscade.ℤ","text":"ℤ (\\bbZ)\n\nan alias for abstract type Integer. For use in dispatching. ℤ1... ℤ4 are AbstractArrays of dimensions 1 to 4. ℤ11 is an AbstractVector of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝔹","page":"Reference manual","title":"Muscade.𝔹","text":"𝔹 (\\bbB)\n\nan alias for Bool. For use in dispatching. 𝔹1... 𝔹4 are AbstractArrays of dimensions 1 to 4.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝕓","page":"Reference manual","title":"Muscade.𝕓","text":"𝕓 (\\bbb)\n\nan alias for Bool. For use in struct definitions. 𝕓1... 𝕓4 are Arrays of dimensions 1 to 4.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝕟","page":"Reference manual","title":"Muscade.𝕟","text":"𝕟 (\\bbn)\n\nan alias for UInt64. For use in struct definitions. 𝕟1... 𝕟4 are Arrays of dimensions 1 to 4.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝕣","page":"Reference manual","title":"Muscade.𝕣","text":"𝕣 (\\bbr)\n\nan alias for Float64. For use in struct definitions. 𝕣1... 𝕣4 are Arrays of dimensions 1 to 4. 𝕣11 is a Vector of Vector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Muscade.𝕫","page":"Reference manual","title":"Muscade.𝕫","text":"𝕫 (\\bbz)\n\nan alias for Int64. For use in struct definitions. 𝕫1... 𝕫4 are Arrays of dimensions 1 to 4. 𝕫11 is a Vector of Vector.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Functions","page":"Reference manual","title":"Functions","text":"","category":"section"},{"location":"reference.html","page":"Reference manual","title":"Reference manual","text":"Modules = [Muscade]\nOrder   = [:function]","category":"page"},{"location":"reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, AbstractMatrix{Muscade.NodID}}} where T<:AbstractElement","page":"Reference manual","title":"Muscade.addelement!","text":"eleid = addelement!(model,ElType,nodid;kwargs...)\n\nAdd one or several elements to model, connecting them to the nodes specified  by nodid.\n\nIf nodid is an AbstractVector: add a single element to the model. eleid is then a single element identifier.\n\nIf nodid is an AbstractMatrix: add multiple elements to the model. Each  row of nodid identifies the node of a single element. eleid is then  a vector of element identifiers.\n\nFor each element, addelement! will call eleobj = ElType(nodes;kwargs...) where nodes is a vector of nodes of the element.\n\nSee also: addnode!, describe, coord\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t<:Real}","page":"Reference manual","title":"Muscade.addnode!","text":"nodid = addnode!(model,coord)\n\nIf coord is an AbstractVector of Real: add a single node to the model.   Muscade does not prescribe what coordinate system to use.  Muscade will handle  to each element the coord of the nodes of the element, and the element  constructor must be able to make sense of it. nodid is a node identifier, that is used as input to addelement!.\n\nIf coord is an AbstractMatrix, its rows are treated as vectors of coordinates. nodid is then a vector of node identifiers.\n\nSee also: addelement!, coord , describe \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.coord-Tuple{AbstractVector{Node}}","page":"Reference manual","title":"Muscade.coord","text":"c = coord(node)\n\nUsed by element constructors to obtain the coordinates of a vector of Nodes handed by Muscade to the constructor. c is accessed as \n\nc[inod][icoord]\n\nwhere inod is the element-node number and icoord an index into a vector of coordinates.\n\nSee also: addnode!, addelement!, describe, solve  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}","page":"Reference manual","title":"Muscade.describe","text":"describe(model,spec)\n\nPrint out information about model. spec can be \n\nan EleID to describe an element,\na DofID to describe a dof.\na NodID to describe a node,\n:doftyp to obtain a list of doftypes, \n:dof to obtain a list of dofs or \n:eletyp for a list of element types.\n\nSee also: addelement!, addnode!\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.describe-Tuple{Muscade.State}","page":"Reference manual","title":"Muscade.describe","text":"describe(state;class=:all)\n\nProvide a description of the dofs stored in state. class can be either :all, :Λ, :ΛX, :X, :U, :A or :scale\n\nSee also: solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.doflist-Union{Tuple{Type{E}}, Tuple{E}} where E<:AbstractElement","page":"Reference manual","title":"Muscade.doflist","text":"Muscade.doflist(::Type{E<:AbstractElement})\n\nElements must overload Muscade's doflist function.   The method must take the element type as only input, and return a NamedTuple with fieldnames inod,class and field.  The tuple-fields are NTuples of the same length.  For example\n\nMuscade.doflist( ::Type{<:Turbine}) = (inod =(1   ,1   ,2        ,2        ),\n                                       class=(:X  ,:X  ,:A       ,:A       ),\n                                       field=(:tx1,:tx2,:Δseadrag,:Δskydrag))\n\nIn Λ, X, U and A handed by Muscade to residual or lagrangian, the dofs in the vectors will follow the order in the doflist. Element developers are free to number their dofs by node, by field, or in any other way.\n\nSee also: lagrangian, residual  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.equal-Tuple{Any}","page":"Reference manual","title":"Muscade.equal","text":"equal(t) → :equal\n\nA function which for any value t returns the symbol equal.  Usefull for specifying the keyword argument mode=equal in adding an element of type `DofConstraint to a Model.\n\nSee also: DofConstraint, ElementConstraint, off, positive\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.findlastassigned-Tuple{Vector}","page":"Reference manual","title":"Muscade.findlastassigned","text":"ilast = findlastassigned(state)\n\nFind the index ilast of the element before the first non assigment element in a vector state.\n\nIn multistep analyses, solve returns a vector state of length equal to the number of steps requested by the user.  If the analysis is aborted, solve still returns any available results at the begining of state, and the vector state[1:ilast] is fully assigned.\n\nSee also: solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getdof-Tuple{Muscade.State}","page":"Reference manual","title":"Muscade.getdof","text":"dofres,dofID = getdof(state;[class=:X],field=:somefield,nodID=[nodids...],[iders=0|1|2])\n\nObtain the value of dofs of the same class and field, at various nodes and for various states.\n\nIf state is a vector, the output dofres has size (ndof,nder+1,nstate). If state is a scalar, the output dofres has size (ndof,nder+1).\n\nSee also: getresult, addnode!, solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getndof-Tuple{DataType}","page":"Reference manual","title":"Muscade.getndof","text":"getndof(model|Element)\ngetndof(model|Element,class)\ngetndof(model|Element,(class1,class2,[,...]))\n\nwhere class can be any of :X, :U, :A: get the number of dofs of the specified dof-classes (default: all classes) for the variable model or the type Element.\n\nSee also: describe\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S<:Muscade.State","page":"Reference manual","title":"Muscade.getresult","text":"eleres = getresult(state,req,eleids)\n\nObtain an array of nested NamedTuples and NTuples of element results. req is a request defined using @request. state a vector of States or a single State. eleids can be either\n\na vector of EleIDs (obtained from addelement!) all corresponding to the same concrete element type\na concrete element type.\n\nIf state is a vector, the output dofres has size (nele,nstate). If state is a scalar, the output dofres has size (nele).\n\nSee also: getdof, @request, @espy, addelement!, solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.getsomedofs-Union{Tuple{Nder}, Tuple{Tuple{Vararg{StaticArraysCore.SVector, Nder}}, Any}} where Nder","page":"Reference manual","title":"Muscade.getsomedofs","text":"rotations = getsomedofs(X,[3,6])\n\nUsed by elements' residual or lagrangian to some degrees of freedom, and their time derivatives, from the variables X and U. \n\nSee also: ∂0,∂1,∂2  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.initialize!-Tuple{Model}","page":"Reference manual","title":"Muscade.initialize!","text":"initialstate = initialize!(model)\n\nFinalize a model (invoquing addnode! and addelement! after initialize! will result in an error)  and return an initial State (with all dofs set to zero, as starting point for an analysis.)\n\nSee also: addnode!, addelement!, solve\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.lagrangian-Tuple{}","page":"Reference manual","title":"Muscade.lagrangian","text":"@espy function Muscade.lagrangian(eleobj::MyElement,Λ,X,U,A,t,χ,χcv,SP,dbg)\n    ...\n    return L,χ,FB\nend\n\nInputs\n\neleobj an element object\nΛ a SVector{nXdof,R} where{R<:Real}, Lagrange multipliers (aka δX virtual displacements).\nX a NTuple of SVector{nXdof,R} where{R<:Real}, containing the Xdofs and, depending on the solver,  their time derivatives. Use x=∂0(X), v=∂1(X) and a=∂2(X) to safely obtain vectors of zeros  where the solver leaves time derivatives undefined.\nU a NTuple of SVector{nUdof,R} where{R<:Real}, containing the Udofs and, depending on the solver,  their time derivatives. Use u=∂0(U), ̇u=∂1(U) and ̈u=∂2(U) to safely obtain vectors of zeros  where the solver leaves time derivatives undefined.\nA a SVector{nAdof,R} where{R<:Real}.\nt a `Real containing the time.\nχ the element memory\nχcv a function used to built the updated element memory.\nSP solver parameters (for example: the barrier parameter γ for  interior point methods).\ndbg a NamedTuple to be used only for debugging purposes.\n\nOutputs\n\nL the lagrangian\nχ an updated element memory. Return noχ if the element has no memory.\nFB feedback from the element to the solver (for example: can γ be  reduced?). Return noFB of the element has no feedback to provide.\n\nSee also: residual, doflist, @espy, ∂0, ∂1, ∂2, noχ, noFB\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.merge-Tuple{Any}","page":"Reference manual","title":"Muscade.merge","text":"req = Muscade.merge(o.req)\n\nElements like ElementCost and ElementConstraint use requests to apply a cost or a constraint to requestables from another \"target\" element. These cost/constraint elements must be coded carefully so that getresult can be used to extracted both requestable internal results from the cost/constraint and from the target element.\n\nmerge (which is not exported by Muscade) is used to merge the requests for the request needed to enforce a cost or constraint, and the user's  request for element to be obtained from the analysis.  The call to merge, to be inserted in the code of lagrange for the cost/constraint element will be modified by @espy.  \n\nSee the code of ElementCost's constructor and lagrange method for an example.\n\nSee also: ElementCost,@request,getresult\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.muscadeerror-Tuple{NamedTuple, Any}","page":"Reference manual","title":"Muscade.muscadeerror","text":"muscadeerror([[dbg,]msg])\n\nThrow a MuscadeException, where\n\ndbg is a NamedTuple that contains \"location information\"\n\n(for example: solver, step, iteration, element, quadrature point) that will be displayed with the error message.\n\nmsg is a String describing the problem.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.off-Tuple{Any}","page":"Reference manual","title":"Muscade.off","text":"off(t) → :off\n\nA function which for any value t returns the symbol off.  Usefull for specifying the keyword argument mode=off in adding an element of type `DofConstraint to a Model.\n\nSee also: [`DofConstraint`](@ref), [`ElementConstraint`](@ref), [`equal`](@ref), [`positive`](@ref)\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.positive-Tuple{Any}","page":"Reference manual","title":"Muscade.positive","text":"positive(t) → :positive\n\nA function which for any value t returns the symbol positive.  Usefull for specifying the keyword argument mode=positive in adding an element of type `DofConstraint to a Model.\n\nSee also: DofConstraint, ElementConstraint, off, equal\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.residual-Tuple{}","page":"Reference manual","title":"Muscade.residual","text":"@espy function Muscade.residual(eleobj::MyElement,X,U,A,t,χ,χcv,SP,dbg)     ...     return R,χ,FB end\n\nThe inputs and outputs to residual are the same as for lagrangian with two exceptions:\n\nresidual does no have input Λ.\nthe first output argument of residual is not a Lagrangian L but R,\n\na SVector{nXdof,R} where{R<:Real}, containing the element's contribution   to the residual of the equations to be solved.     \n\nSee lagrangian for the rest of the inputs and outputs. \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.setscale!-Tuple{Model}","page":"Reference manual","title":"Muscade.setscale!","text":"setscale!(model;scale=nothing,Λscale=nothing)\n\nProvide scaling value for each type (class and field) of dof in the model.   This is usued to improve the conditioning of the incremental problems and for convergence criteria. scale is a NamedTuple with fieldnames within  X, U and A.  Each field is itself a NamedTuple with fieldnames being dof fields, and value being the expected order of magnitude.\n\nFor example scale = (X=(tx=10,rx=1),A=(drag=3.)) should be read as: X-dofs of field :tx are scaled by 10 moters, :rx by radians, and A-dofs of  field drag by 3. All other degrees of freedom are scaled by 1.\n\nDetermining scaling coefficients that improve the condition number of incremental matrices is a hard problem.\n\nΛscale is a scalar. The scale of a Λ-dof will be deemed to be the scale of the  corresponding X-dof, times Λscale.\n\nSee also: addnode!, describe, coord, studyscale\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.solve-Tuple{Type{<:Muscade.AbstractSolver}}","page":"Reference manual","title":"Muscade.solve","text":"solve(Solver;dbg=(;),verbose=true,silenterror=false,kwargs...)\n\nExecute an analysis using Solver, and safeguard partial results in the case of error. \n\nNamed arguments\n\ndbg=(;)           a named tuple to trace the call tree (for debugging)\nverbose=true      set to false to suppress printed output (for testing)\nsilenterror=false set to true to suppress print out of error (for testing) \nkwargs...         Further arguments passed on to the method solve provided by the solver\n\nThis will call the method solve provided by the solver with solve(Solver,pstate,verbose,(dbg...,solver=Symbol(Solver));kwargs...)\n\nSee also: StaticX, StaticXUA, initialize! \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.studyscale-Tuple{Muscade.State}","page":"Reference manual","title":"Muscade.studyscale","text":"scale = studyscale(state;[verbose=false],[dbg=(;)])\n\nReturns a named tuple of named tuples for scaling the model, accessed as     scaled.myclass.myfield, for example scale.X.tx1.\n\ninfo: Info\nCurrently, the format of scale is not identical to the input expected by setscale!: work in progress\n\nIf verbose=true, prints out a report of the analysis underlying the proposed scale.  The proposed scaling depends on the state passed as input - as it is computed for a given incremental matrix.\n\nSee also: setscale!\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.studysingular-Tuple{Muscade.State}","page":"Reference manual","title":"Muscade.studysingular","text":"matrix = studysingular(state;SP,[iclasses=(Λ,:X,:U,:A)],[jclasses=iclasses],[verbose::𝕓=true],[dbg=(;)])\n\nGenerates an incremental matrix for state (no time derivatives) corresponding to the classes required,  and report on the null space of the matrix.\n\nTo do so, the incremental matrix is converted to full format, limiting the applicability to small models.\n\nThe function returns the incremental matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.toggle-Union{Tuple{Tb}, Tuple{Ta}, Tuple{Bool, Ta, Tb}} where {Ta, Tb}","page":"Reference manual","title":"Muscade.toggle","text":"toggle(condition,a,b)\n\nTypestable equivalent of condition ? a : b.   Returns a value converted to promote_type(typeof(a),typeof(b))\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.∂0-Tuple{Any}","page":"Reference manual","title":"Muscade.∂0","text":"position = ∂0(X)\n\nUsed by elements' residual or lagrangian to extract the zero-th order time derivative from the variables X and U.\n\nSee also: ∂1,∂2,getsomedofs  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.∂1-Tuple{Any}","page":"Reference manual","title":"Muscade.∂1","text":"velocity = ∂1(X)\n\nUsed by elements' residual or lagrangian to extract the first order time derivative from the variables X and U. Where the solver does not provide this derivative (e.g. a static solver), the output is a vector of zeros.\n\nSee also: ∂0,∂2,getsomedofs  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Muscade.∂2-Tuple{Any}","page":"Reference manual","title":"Muscade.∂2","text":"position = ∂2(X)\n\nUsed by elements' residual or lagrangian to extract the zero-th order time derivative from the variables X and U. Where the solver does not provide this derivative (e.g. a static solver), the output is a vector of zeros.\n\nSee also: ∂0,∂1,getsomedofs  \n\n\n\n\n\n","category":"method"},{"location":"reference.html#Macros","page":"Reference manual","title":"Macros","text":"","category":"section"},{"location":"reference.html","page":"Reference manual","title":"Reference manual","text":"Modules = [Muscade]\nOrder   = [:macro]","category":"page"},{"location":"reference.html#Muscade.@espy-Tuple{Any}","page":"Reference manual","title":"Muscade.@espy","text":"@espy function ... end\n\nFrom an anotated function code, generate     - \"clean\" code, in which the anotations have been deleted, and with        the call syntax argout... = foo(argin...)     - \"espying\" code, with added input and ouput arguments       argout...,res = foo(argin...,req) where req has been       generated using @request and res is a nested structure       of NamedTuples and NTuples containing the requested data.\n\nThe macro is not general: it is designed for residual and lagrangian, which for performance have to be programmed in \"immutable\" style: they must never mutate variables (this implies in particular, no adding into an array in a loop over Gauss points). So @espy only supports the specific programming constructs needed in this style.\n\nThe following is an example of anotated code:\n\n@espy function residual(x::Vector{R},y) where{R<:Real}\n    ngp=2\n    accum = ntuple(ngp) do igp\n        ☼z = x[igp]+y[igp]\n        ☼s,☼t  = ☼material(z)\n        ♢square = s^2\n        @named(s) \n    end\n    r = sum(i->accum[i].s,ngp)\n    return r,nothing,nothing\nend\n\nThe keyword function is preceded by the macro-call @espy.  \nThe name of requestable variables is preceded by ☼ (\\sun).  Such anotation must always appear on the left of an assigment. \nIf the name of a variable is preceded by ♢ (\\diamond), then the variable is evaluated only if requested. Such a notation can only be used if there is only one variable left of the assignement.\nThe name of a function being called must be preceded by ☼ if the definition of the function is itself preceeded by the macro-call @espy.\nfor-loops are not supported. do-loops must be used: to be efficient,  residual and lagrangian must not allocate and thus use immutables.\nThe keyword return must be explicitly used, and if must be followed the a comma separated list of output variables. Syntaxes like return if... are not supported.  \n\nSee also: @request, @espydbg, getresult\n\n\n\n\n\n","category":"macro"},{"location":"reference.html#Muscade.@espydbg-Tuple{Any}","page":"Reference manual","title":"Muscade.@espydbg","text":"@espydbg function ... end\n\nGenerate the same code as @espy and print it (for debug purposes).\n\nSee also: @espy, @request\n\n\n\n\n\n","category":"macro"},{"location":"reference.html#Muscade.@once-Tuple{Any}","page":"Reference manual","title":"Muscade.@once","text":"@once f(x)= x^2\n\ndo not parse the definition of function f again if not modified. Using in a script, this prevents recompilations in Muscade or applications based on it when they receive such functions as argument\n\n\n\n\n\n","category":"macro"},{"location":"reference.html#Muscade.@request-Tuple{Any}","page":"Reference manual","title":"Muscade.@request","text":"req = @request expr\n\nCreate a request of internal results wanted from a function. Considering the function presented as example for @espy, examples of possible syntax include\n\nreq       = @request gp(s,z,material(a,b))\nreq       = @request gp(s)\nreq       = @request gp(material(a))\n\nThe first expression can be read as follows: \"In the function, there is a do loop over variable igp, and within this loop a call to a function material.  Results s and z are wanted from within the loop, and results a and b from within material.\n\nThe corresponding datastructure containing the results for each element is a nesting of NTuples and NamedTuples,  and can be accessed as out.gp[igp].material.a and so forth.        \n\nSee also: @espy, @espydbg\n\n\n\n\n\n","category":"macro"},{"location":"reference.html#Index","page":"Reference manual","title":"Index","text":"","category":"section"},{"location":"reference.html","page":"Reference manual","title":"Reference manual","text":"","category":"page"},{"location":"LICENSE.html#MIT-License","page":"MIT License","title":"MIT License","text":"","category":"section"},{"location":"LICENSE.html","page":"MIT License","title":"MIT License","text":"Copyright (c) 2022-2023 SINTEF Ocean","category":"page"},{"location":"LICENSE.html","page":"MIT License","title":"MIT License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"LICENSE.html","page":"MIT License","title":"MIT License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"LICENSE.html","page":"MIT License","title":"MIT License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"CurrentModule = Muscade","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"info: Info\nMuscade.jl is still under development, and not ready for general usage:New versions may introduce breaking changes in user and element APIs.\nGraphics generation will be revised.\nNew solvers will be added.","category":"page"},{"location":"index.html#purpose","page":"Purpose","title":"Purpose","text":"","category":"section"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Muscade.jl: Create and solve optimization-FEM models.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Framework: Muscade provides an API to create new elements and new solvers.  It also provides the \"piping\" - facilities to create models, assemble matrices and vectors and extract and export results. As a framework, Muscade does not provide finite element types modeling any specific domain of physics.  It does however provide some domain-agnostic element types for doing things like introducing boundary conditions and introducing costs. ","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"The API to create new elements is quite classic (given degrees of freedom, compute their duals, aka. residuals): as such Muscade is not a modelling language like for example UFL which provides a formalism in which a \"well posed problem\" can be defined with domain, differential equations and boundary conditions.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"In order to obtain high performance, elements have to be implemented using a specific programming style: functional programming, using immutables.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Rapid development: Muscade lets application developer focus on the interesting parts: formulating new element types and creating new solvers.  Muscade takes care of the tedious parts.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"It further accelerates the rapid development of new element types by using automatic differentiation and automatic extraction of element-results (think of stresses and strains, in an element that given nodal displacements computes nodal forces).  This results in shorter and more readable element code.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"The idea is thus to be able to produce specialised FEM applications, at low cost, to create highly efficient solution to niche problems.  It is also hope that Muscade will help students of the finite element method to put theory into practice.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Multiphysics: When creating a new element, one must define a function doflist to describe the class (see below) field and node of each degree of freedom (dof). Element developers can introduce new fields (node rotation, hydrogen concentration, temperature, components of the magnetic field...).  The user can then associate a scale to each field stating that \"displacements are the order of 10^-3 m\" or \"potentials are of the order of kV.  This is used to improve the conditioning of the problem.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Optimization: Muscade handles optimization-FEM problems, that is, optimization problems constrained by equilibrium of the FEM model.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Optimization-FEM consists in optimising a target function (here called the cost function) under the constraint that a FEM model be exactly verified. This in turn implies that the problem has more unknowns than the model has equation (or at least: more unknowns than linearly independent equations, as would be the case with “insufficient” boundary conditions).","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"The unknowns that are dual to the FEM equations are noted X-dofs, and sometimes refered to as “response dofs”. The rest of the unknowns can be separated into U-dofs (varying with time, generaly unknown loads) and A-dofs (comstant over time, generaly unknown model parameters). The conditions for such a constrained optimization problem to be well-posed are the Babushka-Brezzi conditions, which say, in essence “if you do not restrain, then at least measure”.","category":"page"},{"location":"index.html#Applications-of-optimization-FEM","page":"Purpose","title":"Applications of optimization-FEM","text":"","category":"section"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Besides solving well-posed FEM problems (obtaining the repsonse of a system, given adequate boundary conditions and known loading terms), many applications can be, or should be possible within Muscade.","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Reliability analysis: Finding a design point. What is the most probable combination of external loads U and strength of the structure A that may cause the response X to exceed, in one of many ways, the acceptable?","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Design optimization: What is the cheapest way to engineer a system (for example a structure) that will survive a set of loading conditions?","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Load identification and monitoring: Given incomplete and noisy measurements of the response of a system, what are the loads that are most likely to cause a response close to what has been measured?","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Optimal control: how to steer a system with many dofs into a wanted behaviour?","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Model identification: given enough measurements on the response of a system responding to at least partly unknown load, is it possible to adjust the model of the system (model calibration, damage detection)?","category":"page"},{"location":"index.html","page":"Purpose","title":"Purpose","text":"Sensor array optimization: how best to place sensors in a system in order to support the above applications?","category":"page"}]
}
