<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating an element · Muscade.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Muscade.jl logo"/></a><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Purpose</a></li><li><a class="tocitem" href="Theory.html">Theory</a></li><li><a class="tocitem" href="Modelling.html">Creating a model</a></li><li class="is-active"><a class="tocitem" href="Elements.html">Creating an element</a><ul class="internal"><li><a class="tocitem" href="#Introducton"><span>Introducton</span></a></li><li><a class="tocitem" href="#DataType"><span>DataType</span></a></li><li><a class="tocitem" href="#Constructor"><span>Constructor</span></a></li><li><a class="tocitem" href="#Muscade.doflist"><span><code>Muscade.doflist</code></span></a></li><li><a class="tocitem" href="#Muscade.lagrangian"><span><code>Muscade.lagrangian</code></span></a></li><li><a class="tocitem" href="#Muscade.residual"><span><code>Muscade.residual</code></span></a></li><li><a class="tocitem" href="#Help-functions"><span>Help functions</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li></ul></li><li><a class="tocitem" href="Solvers.html">Creating a solver</a></li><li><a class="tocitem" href="Builtin_els.html">Built-in elements</a></li><li><a class="tocitem" href="Builtin_sol.html">Built-in solvers</a></li><li><a class="tocitem" href="TypeStable.html">Type-stability</a></li><li><a class="tocitem" href="Memory.html">Memory management</a></li><li><a class="tocitem" href="Adiff.html">Automatic differentiation</a></li><li><a class="tocitem" href="reference.html">Reference manual</a></li><li><a class="tocitem" href="LICENSE.html">MIT License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Elements.html">Creating an element</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Elements.html">Creating an element</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SINTEF/Muscade.jl/blob/master/docs/src/Elements.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-an-element"><a class="docs-heading-anchor" href="#Creating-an-element">Creating an element</a><a id="Creating-an-element-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-element" title="Permalink"></a></h1><h2 id="Introducton"><a class="docs-heading-anchor" href="#Introducton">Introducton</a><a id="Introducton-1"></a><a class="docs-heading-anchor-permalink" href="#Introducton" title="Permalink"></a></h2><p>New element types, providing new element formulations or adressing new domains in physics are implemented by implementing a datatype and methods for function defined by <code>Muscade</code>: </p><ul><li>A <strong>constructor</strong> which is called when the user adds an element to the model.</li><li><strong><code>Muscade.doflist</code></strong> specifies the degrees of freedom (dofs) of the element.</li><li><strong><code>Muscade.residual</code></strong> takes element dofs as input and returns the element&#39;s additive contribution to a non-linear system of equations to be solved (a residual aka. a right hand side),</li><li><strong><code>Muscade.lagrangian</code></strong> takes element dofs as input and returns the element&#39;s additive contribution to a function to be extremized (Lagrangian aka. cost function, surprisal...)</li></ul><p>Each element must implement a constructor following a format specified by <code>Muscade</code>, as well as <code>Muscade.doflist</code>.  Each element must also implement <em>either</em> <code>Muscade.lagrangian</code> <em>or</em> <code>Muscade.residual</code>, depending on what is more natural.</p><h2 id="DataType"><a class="docs-heading-anchor" href="#DataType">DataType</a><a id="DataType-1"></a><a class="docs-heading-anchor-permalink" href="#DataType" title="Permalink"></a></h2><p>For a new element type <code>MyELement</code>, the datatype is defined as</p><pre><code class="language-julia">struct MyElement &lt;: AbstractElement
    ...
end</code></pre><p><code>MyElement</code> <em>must</em> be a subtype of <code>AbstractElement</code>.</p><h2 id="Constructor"><a class="docs-heading-anchor" href="#Constructor">Constructor</a><a id="Constructor-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor" title="Permalink"></a></h2><p>The element must provide a constructor of the form</p><pre><code class="language-julia">function MyElement(nod::Vector{Node};kwargs...)
    ...
    return eleobj
end</code></pre><p>which will then call the default constructor provided by Julia.  </p><p><code>nod</code> can be used to access the coordinates of the nodes:</p><pre><code class="language-julia">x = nod[inod].coord[icoord]</code></pre><p>where <code>inod</code> is the element-node number and <code>icoord</code> the index into a vector of coordinates. <code>coord</code> is  provided by the user when adding a <code>Node</code> to the <code>Model</code>. <code>Muscade</code> has no opinion about, and provides no check of, the length of <code>coord</code> provided by the user. In this way elements can define what coordinate system (how many coordinates, and their interpretation) is to be used.  Coordinate systems can even differ from one node to the next. See also <a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>coord</code></a>.</p><p><code>kwargs...</code> is any number of named arguments, typicaly defining the material properties of the element.</p><p>The user does not call the above-defined element directly.  Instead, an element is added to the model by a call of the form</p><pre><code class="language-julia">e1 = addelement!(model,MyElement,nodid,kwargs...)</code></pre><p>See <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>.</p><h2 id="Muscade.doflist"><a class="docs-heading-anchor" href="#Muscade.doflist"><code>Muscade.doflist</code></a><a id="Muscade.doflist-1"></a><a class="docs-heading-anchor-permalink" href="#Muscade.doflist" title="Permalink"></a></h2><p>The element must provide a method of the form</p><pre><code class="language-julia">function Muscade.doflist(::Type{MyElement})
    return (inod =(...),
            class=(...),
            field=(...))
end</code></pre><p>The syntax <code>::Type{MyElement}</code> is because <code>doflist</code> will be called by <code>Muscade</code> with a <code>DataType</code> (the type <code>MyElement</code>). The function name must begin with <code>Muscade.</code> to make it possible to overload a function defined in the module <code>Muscade</code>. </p><p>The return value of the function is a <code>NamedTuple</code> with the fields <code>inod</code>, <code>class</code> and <code>field</code>. </p><ul><li><code>inod</code>  is a <code>NTuple</code> of <code>Int64</code>: for each dof, its element-node number. </li><li><code>class</code> is a <code>NTuple</code> of <code>Symbol</code>: for each dof, its class (must be <code>:X</code>, <code>:U</code> or <code>:A</code>).</li><li><code>field</code> is a <code>NTuple</code> of <code>Symbol</code>: for each dof, its field.</li></ul><p>Importantly, <code>doflist</code> does not mention dofs of class <code>:Λ</code>: if the element implements <code>lagrangian</code>, there is automaticaly a one-to-one correspondance between Λ-dofs and X-dofs.</p><p>For example (using Julia&#39;s syntax for one-liner functions):</p><pre><code class="language-julia">Muscade.doflist( ::Type{Turbine}) = (inod =(1   ,1   ,2        ,2        ),
                                     class=(:X  ,:X  ,:A       ,:A       ),
                                     field=(:tx1,:tx2,:Δseadrag,:Δskydrag))</code></pre><p>See <a href="reference.html#Muscade.doflist-Union{Tuple{Type{E}}, Tuple{E}} where E&lt;:AbstractElement"><code>doflist</code></a>.</p><h2 id="Muscade.lagrangian"><a class="docs-heading-anchor" href="#Muscade.lagrangian"><code>Muscade.lagrangian</code></a><a id="Muscade.lagrangian-1"></a><a class="docs-heading-anchor-permalink" href="#Muscade.lagrangian" title="Permalink"></a></h2><p>Elements that implement a cost on the degrees of freedom must implement a method of the form</p><p>See <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>lagrangian</code></a> for the list of arguments and outputs.</p><h3 id="Automatic-differentiation"><a class="docs-heading-anchor" href="#Automatic-differentiation">Automatic differentiation</a><a id="Automatic-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation" title="Permalink"></a></h3><p>The gradients and Hessians of <code>L</code> do not need to be implemented, because <code>Muscade</code> uses automatic  differentiation. Because of this, it is important not to over-specify the inputs.  For example,  implementing a function header with</p><pre><code class="language-julia">@espy function Muscade.lagrangian(o::MyElement,Λ::Vector{Float64},X,U,A,t,χ,χcv,SP,dbg)
#                                               ____bad_idea____</code></pre><p>would cause a <code>MethodError</code>, because <code>Muscade</code> will attempt to call with a <code>SVector</code> instead of <code>Vector</code>, and a special datatype supporting automatic diffeentiation instead of <code>Float64</code>.</p><h3 id="Extraction-of-element-results"><a class="docs-heading-anchor" href="#Extraction-of-element-results">Extraction of element-results</a><a id="Extraction-of-element-results-1"></a><a class="docs-heading-anchor-permalink" href="#Extraction-of-element-results" title="Permalink"></a></h3><p>The function definition must be anotated with the macro call <code>@espy</code>.  Variables within the body of <code>lagrange</code>, which the user may want to obtain must be anotated with <code>☼</code> (by typing <code>\sun</code> they pressing <code>TAB</code>) at the place where they are calculated. An example would be </p><pre><code class="language-julia">    ☼σ = E*ε</code></pre><p>The macro will generate two versions of <code>lagrange</code>.  One in which the anotations <code>☼</code> are taken away, which is used to solve the numerical problem.  Another with additional input and output variables, and code inserted into the body of the function to extract results wanted by the user.</p><p>See <a href="reference.html#Muscade.@espy-Tuple{Any}"><code>@espy</code></a> for a complete guide on code anotations. </p><h2 id="Muscade.residual"><a class="docs-heading-anchor" href="#Muscade.residual"><code>Muscade.residual</code></a><a id="Muscade.residual-1"></a><a class="docs-heading-anchor-permalink" href="#Muscade.residual" title="Permalink"></a></h2><p>Elements that implement &quot;physics&quot; will typicaly implement <code>residual</code> (they could implement the same using <code>lagrangian</code>, but the resulting code would be less performant).</p><p>The interface is mostly the same as for <code>lagrangian</code> with the differences that</p><ul><li><code>residual</code> returns a vector <code>R</code></li><li>there is no argument <code>Λ</code></li></ul><pre><code class="language-julia">@espy function Muscade.residual(o::MyElement,X,U,A,t,χ,χcv,SP,dbg) 
    ...
    return R,noχ,noFB
end</code></pre><h3 id="Immutables-and-Gauss-quadrature"><a class="docs-heading-anchor" href="#Immutables-and-Gauss-quadrature">Immutables and Gauss quadrature</a><a id="Immutables-and-Gauss-quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Immutables-and-Gauss-quadrature" title="Permalink"></a></h3><p><code>residual</code> is called many times and it is critical to obtain high performance. Thus, allocating the vector <code>R</code> on the heap  within the function must be avoided. A design option would be to have <code>Muscade</code> pass a preallocated vector <code>R</code> and have  residual mutate its argument.  For &quot;forward&quot; automatic differentiation, it can be difficult to predict the element type of <code>R</code>, and other techniques of automatic differentiaton do not accomodate mutations.</p><p>For this reason, <code>residual</code> and <code>lagrange</code> must be writen in a functional style, using only immutable variables, and in particular immutable arrays.  This can be done using <code>StaticArrays.jl</code> (tested) or <code>Tensorial.jl</code> (not tested with <code>Muscade</code>), and generaly results in very readable code that directly expresses concepts of linear algebra.</p><p>One difficulty arises with Gauss quadrature.  Typical implementations would rely on setting <code>R</code> to zero, then adding the  contributions from quadrature points to <code>R</code> within a <code>for</code> loop over the Gauss points.  The pseudo code (not valid in <code>Muscade</code>):</p><pre><code class="language-julia">R .= 0
for igp = 1:ngp
    F = ...
    Σ = ...
    R += F ∘ Σ ∘ ∇N * dV
end</code></pre><p>shows that <code>R</code> is mutated. A pseudocode in immutable style would be</p><pre><code class="language-julia">@espy function residual(x,χ)
    t = ntuple(ngp) do igp
        ☼F = ...
        ☼Σ = ...
        r = F ∘ Σ ∘ ∇N * dV
        @named(χ,r)
    end
    χ = ntuple(igp-&gt;t[igp].χ,ngp)
    R = sum(   igp-&gt;t[igp].r,ngp)
    return R,χ
end</code></pre><p><code>r</code> are the contributions to <code>R</code> at each quadrature point.  The operation <code>t = ntuple ...</code> returns a datastructure <code>t</code> such that <code>t[igp].χ</code> are the memory variable and `<code>t[igp].r</code> the contribution to the residual from the <code>igp</code>-th quadrature point. This is because</p><pre><code class="language-julia">    t = ntuple(ngp) do igp
        expr(igp)
    end    </code></pre><p>is equivalent to </p><pre><code class="language-julia">    t = ntuple(expr for igp=1:ngp)</code></pre><p>which returns</p><pre><code class="language-julia">    t = (expr(1),expr(2),...,expr(ngp))</code></pre><p>where the value of <code>expr</code> is that of its last line <code>@named(χ,r)</code> which is a macro provided by <code>Muscade</code> that inserts the code <code>(χ=χ,r=r)</code>.</p><p>The code </p><pre><code class="language-julia">    χ = ntuple(igp-&gt;t[igp].χ,ngp)
    R = sum(   igp-&gt;t[igp].r,ngp)</code></pre><p>gathers the memories of all quadrature points into a <code>Tuple</code> and adds together the contributions <code>r</code> into the residual <code>R</code>.</p><p>See <a href="reference.html#Muscade.residual-Tuple{}"><code>residual</code></a>.</p><h2 id="Help-functions"><a class="docs-heading-anchor" href="#Help-functions">Help functions</a><a id="Help-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Help-functions" title="Permalink"></a></h2><p><code>Muscade</code> provides functions and constants to make it easier to comply with the API:</p><ul><li>Element constructors can use function <a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>coord</code></a> to extract the coordinates fron the <code>Vector{Node}</code> they get as first argument.</li><li><code>residual</code> and <code>lagrangian</code> <strong>must</strong> use <a href="reference.html#Muscade.∂0-Tuple{Any}"><code>∂0</code></a>, <a href="reference.html#Muscade.∂1-Tuple{Any}"><code>∂1</code></a> and <a href="reference.html#Muscade.∂2-Tuple{Any}"><code>∂2</code></a> when extracting the zeroth, first and second time derivatives from arguments <code>X</code> and <code>U</code>.</li><li>Constants <a href="reference.html#Muscade.noχ"><code>noχ</code></a> and <a href="reference.html#Muscade.noFB"><code>noFB</code></a> (which have value <code>nothing</code>) can be used by elements that do not have memory or no feedback to the solving procedure.</li></ul><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><p>For a given element formulation, the performance of <code>residual</code> and <code>lagrangian</code> can vary with a factor up to 100 between a good and a bad implementation.</p><p><strong>Type stable code</strong> allows the compiler to know the type of every variable in a function given the type of its parameters. Code that is type unstable is significantly slower. See the page on <a href="TypeStable.html">type stability</a>.</p><p><strong>Allocation</strong>, and the corresponding deallocation of memory <em>on the heap</em> takes time. By contrast, allocation and deallocation <em>on the stack</em> is fast.  In Julia, only immutable variables can be allocated on the stack. See the page on <a href="Memory.html">memory management</a></p><p><strong>Automatic differentiation</strong> generaly does not affect how <code>residual</code> and <code>lagrangian</code> are writen.  There are two performance-related exceptions to this:</p><ol><li>If a complex sub function in <code>residual</code> and <code>lagrangian</code> (typicaly a material model or other closure) operates on an array (for example, the strain) that is smaller than the number of degrees of freedom of the system, computing time can be saved by computing the derivative of the output (in the example, the stress) with respect to the input to the subfunction, and then compose the derivatives.</li><li>Iterative precedures are sometimes used within <code>residual</code> and <code>lagrangian</code>, a typical example being in plastic material formulations.  There is no need to propagate automatic differentiation through all the iterations - doing so with the result of the iteration provides the same result.</li></ol><p>See the page on <a href="Adiff.html">automatic differentiation</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Modelling.html">« Creating a model</a><a class="docs-footer-nextpage" href="Solvers.html">Creating a solver »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 15 June 2023 06:58">Thursday 15 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
