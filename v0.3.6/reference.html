<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference manual ¬∑ Muscade.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Muscade.jl logo"/></a><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Purpose</a></li><li><a class="tocitem" href="README.html">Getting started</a></li><li><a class="tocitem" href="Theory.html">FEM-optimization</a></li><li><a class="tocitem" href="Modelling.html">Creating a model</a></li><li><a class="tocitem" href="Elements.html">Creating an element</a></li><li><a class="tocitem" href="Solvers.html">Creating a solver</a></li><li><a class="tocitem" href="Builtin_els.html">Built-in elements</a></li><li><a class="tocitem" href="Builtin_sol.html">Built-in solvers</a></li><li><a class="tocitem" href="TypeStable.html">Type-stability</a></li><li><a class="tocitem" href="Memory.html">Memory management</a></li><li><a class="tocitem" href="Adiff.html">Automatic differentiation</a></li><li class="is-active"><a class="tocitem" href="reference.html">Reference manual</a><ul class="internal"><li><a class="tocitem" href="#Constants"><span>Constants</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Macros"><span>Macros</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="LICENSE.html">MIT License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="reference.html">Reference manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="reference.html">Reference manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SINTEF/Muscade.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="reference"><a class="docs-heading-anchor" href="#reference">Reference manual</a><a id="reference-1"></a><a class="docs-heading-anchor-permalink" href="#reference" title="Permalink"></a></h1><h2 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Muscade.noFB" href="#Muscade.noFB"><code>Muscade.noFB</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">noFB</code></pre><p>A constant, used by elements&#39; <code>residual</code> or <code>lagrangian</code> as their 3rd output if they do provide  any feedback to the solver (for example, on the reduction of the barrier parameter in interior point method).</p><p>Example: <code>return L,noœá,noFB</code></p><p>See also: <a href="reference.html#Muscade.noFB"><code>noFB</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ElementAPI.jl#L14-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.noœá" href="#Muscade.noœá"><code>Muscade.noœá</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">noœá</code></pre><p>A constant, used by elements&#39; <code>residual</code> or <code>lagrangian</code> as their 2nd output if they do not export any material memory (for example, plastic strain).</p><p>Example: <code>return L,noœá,noFB</code></p><p>See also: <a href="reference.html#Muscade.noFB"><code>noFB</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ElementAPI.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.œµ" href="#Muscade.œµ"><code>Muscade.œµ</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">œµ (\epsilon)</code></pre><p>an alias for <code>Base.eps(ùï£)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.‚àû" href="#Muscade.‚àû"><code>Muscade.‚àû</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">‚àû (\infty)</code></pre><p>an alias for <code>Base.inf</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L78-L82">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Muscade.AbstractElement" href="#Muscade.AbstractElement"><code>Muscade.AbstractElement</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractElement</code></pre><p>An abstract data type.  An element type <code>MyElement</code> must be declared as a subtype of <code>AbstractElement</code>.</p><p><code>MyELement</code>must provide a constructor with interface</p><pre><code class="language-none">`eleobj = MyElement(nod::Vector{Node}; kwargs...)`</code></pre><p>See also: <a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>coord</code></a>, <a href="reference.html#Muscade.Node"><code>Node</code></a>, <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>lagrangian</code></a>    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ModelDescription.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.DofConstraint" href="#Muscade.DofConstraint"><code>Muscade.DofConstraint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DofConstraint{Œªclass,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,
    afield,Œªinod,Œªfield,Tg,Tmode} &lt;: AbstractElement</code></pre><p>An element to apply physical/optimisation equality/inequality constraints on dofs. </p><p>The constraints are holonomic, i.e. they apply to the values, not the time derivatives, of the involved dofs.  This element is very general but not very user-friendly to construct, factory functions are provided for better useability.  The sign convention is that the gap <code>g‚â•0</code> and the Lagrange multiplier <code>Œª‚â•0</code>.</p><p>This element can generate three classes of constraints, depending on the input argument <code>Œªclass</code>.</p><ul><li><code>Œªclass=:X</code> Physical constraint.  In mechanics, the Lagrange multiplier dof is a   generalized force, dual of the gap. The gap function must be of the form <code>gap(x,t,gargs...)</code>.</li><li><code>Œªclass=:U</code> Time varying optimisation constraint. For example: find <code>A</code>-parameters so that  at all times, the response does not exceed a given criteria. The gap function must be of the form     <code>gap(x,u,a,t,gargs...)</code>.</li><li><code>Œªclass=:A</code> Time invariant optimisation constraint. For example: find <code>A</code>-parameters such that  <code>A[1]+A[2]=gargs.somevalue</code>. The gap function must be of the form <code>gap(a,gargs...)</code>.</li></ul><p><strong>Named arguments to the constructor</strong></p><ul><li><code>xinod::NTuple{Nx,ùï´}=()</code>       For each X-dof to be constrained, its element-node number.</li><li><code>xfield::NTuple{Nx,Symbol}=()</code> For each X-dof to be constrained, its field.</li><li><code>uinod::NTuple{Nu,ùï´}=()</code>       For each U-dof to be constrained, its element-node number.</li><li><code>ufield::NTuple{Nu,Symbol}=()</code> For each U-dof to be constrained, its field.</li><li><code>ainod::NTuple{Na,ùï´}=()</code>       For each A-dof to be constrained, its element-node number.</li><li><code>afield::NTuple{Na,Symbol}=()</code> For each A-dof to be constrained, its field.</li><li><code>Œªinod::ùï´</code>                     The element-node number of the Lagrange multiplier.</li><li><code>Œªclass::Symbol</code>               The class (<code>:X</code>,<code>:U</code> or <code>:A</code>) of the Lagrange multiplier.                                 See the explanation above for classes of constraints</li><li><code>Œªfield::Symbol</code>               The field of the Lagrange multiplier.</li><li><code>g‚Çõ::ùï£=1.</code>                      A scale for the gap.</li><li><code>Œª‚Çõ::ùï£=1.</code>                      A scale for the Lagrange multiplier.</li><li><code>gap::Function</code>                The gap function.</li><li><code>gargs::NTuple</code>                Additional inputs to the gap function.</li><li><code>mode::Function</code>               where <code>mode(t::‚Ñù) -&gt; Symbol</code>, with value <code>:equal</code>,                                 <code>:positive</code> or <code>:off</code> at any time. An <code>:off</code> constraint                                 will set the Lagrange multiplier to zero.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">using Muscade
model           = Model(:TestModel)
n1              = addnode!(model,ùï£[0]) 
e1              = addelement!(model,DofConstraint,[n1],xinod=(1,),xfield=(:t1,),
                              Œªinod=1, Œªclass=:X, Œªfield=:Œª1,gap=(x,t)-&gt;x[1]+.1,
                              mode=positive)
e2              = addelement!(model,QuickFix  ,[n1],inod=(1,),field=(:t1,),
                              res=(x,u,a,t)-&gt;0.4x.+.08+.5x.^2)
initialstate    = initialize!(model)
state           = solve(StaticX;initialstate,time=[0.],verbose=false) 
X               = state[1].X[1]</code></pre><p>See also: <a href="reference.html#Muscade.Hold"><code>Hold</code></a>, <a href="reference.html#Muscade.off-Tuple{Any}"><code>off</code></a>, <a href="reference.html#Muscade.equal-Tuple{Any}"><code>equal</code></a>, <a href="reference.html#Muscade.positive-Tuple{Any}"><code>positive</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L232-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.DofCost" href="#Muscade.DofCost"><code>Muscade.DofCost</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DofCost{Class,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,
    afield,Tcost,Tcostargs} &lt;: AbstractElement</code></pre><p>An element to apply costs on combinations of dofs.  </p><p><strong>Named arguments to the constructor</strong></p><ul><li><code>xinod::NTuple{Nx,ùï´}=()</code>       For each X-dof to enter <code>cost</code>, its element-node number.</li><li><code>xfield::NTuple{Nx,Symbol}=()</code> For each X-dof to enter <code>cost</code>, its field.</li><li><code>uinod::NTuple{Nu,ùï´}=()</code>       For each U-dof to enter <code>cost</code>, its element-node number.</li><li><code>ufield::NTuple{Nu,Symbol}=()</code> For each U-dof to enter <code>cost</code>, its field.</li><li><code>ainod::NTuple{Na,ùï´}=()</code>       For each A-dof to enter <code>cost</code>, its element-node number.</li><li><code>afield::NTuple{Na,Symbol}=()</code> For each A-dof to enter <code>cost</code>, its field.</li><li><code>class:Symbol</code>                 <code>:A</code> for cost on A-dofs only, <code>:I</code> (&quot;instant&quot;) otherwise.</li><li><code>cost::Function</code>               if <code>class==:I</code>, <code>cost(X,U,A,t,costargs...)‚Üí‚Ñù</code>                                if <code>class==:A</code>, <code>cost(A,costargs...)‚Üí‚Ñù</code>                                 <code>X</code> and <code>U</code> are tuples (derivates of dofs...), and <code>‚àÇ0(X)</code>,<code>‚àÇ1(X)</code>,<code>‚àÇ2(X)</code>                                 must be used by <code>cost</code> to access the value and derivatives of <code>X</code> (resp. <code>U</code>) </li><li><code>costargs::NTuple</code></li></ul><p><strong>Requestable internal variables</strong></p><ul><li><code>cost</code>, the value of the cost.</li></ul><p><strong>Example</strong></p><pre><code class="language-none">ele1 = addelement!(model,DofCost,[nod1],xinod=(1,),field=(:tx1,),
       class=:I,cost=(X,U,A,t)-&gt;X[1]^2</code></pre><p>See also: <a href="reference.html#Muscade.SingleDofCost"><code>SingleDofCost</code></a>, <a href="reference.html#Muscade.ElementCost"><code>ElementCost</code></a>, <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.DofLoad" href="#Muscade.DofLoad"><code>Muscade.DofLoad</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DofLoad{Tvalue,Field} &lt;: AbstractElement</code></pre><p>An element to apply a loading term to a single X-dof.  </p><p><strong>Named arguments to the constructor</strong></p><ul><li><code>field::Symbol</code>.</li><li><code>value::Function</code>, where <code>value(t::‚Ñù) ‚Üí ‚Ñù</code>.</li></ul><p><strong>Requestable internal variables</strong></p><ul><li><code>F</code>, the value of the load.</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using Muscade
model = Model(:TestModel)
node  = addnode!(model,ùï£[0,0])
e     = addelement!(model,DofLoad,[node];field=:tx,value=t-&gt;3t-1)</code></pre><p>See also: <a href="reference.html#Muscade.Hold"><code>Hold</code></a>, <a href="reference.html#Muscade.DofCost"><code>DofCost</code></a>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L143-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.ElementCost" href="#Muscade.ElementCost"><code>Muscade.ElementCost</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementCost{Teleobj,Treq,Tcost,Tcostargs} &lt;: AbstractElement</code></pre><p>An element to apply costs on another element&#39;s element-results.  </p><p><strong>Named arguments to the constructor</strong></p><ul><li><code>req</code>               a request for element-results for <code>ElementType</code>, resulting in the output <code>eleres</code></li><li><code>cost</code>              a cost function <code>cost(eleres,X,U,A,t,costargs...)‚Üí‚Ñù</code>                     <code>X</code> and <code>U</code> are tuples (derivates of dofs...), and <code>‚àÇ0(X)</code>,<code>‚àÇ1(X)</code>,<code>‚àÇ2(X)</code>                      must be used by <code>cost</code> to access the value and derivatives of <code>X</code> (resp. <code>U</code>) </li><li><code>costargs=(;)</code>      A named tuple of additional arguments to the cost function </li><li><code>ElementType</code>       The named of the constructor for the relevant element </li><li><code>elementkwargs...</code>  Additional named arguments to the <code>ElementCost</code> constructor are passed on to the <code>ElementType</code> constructor.     </li></ul><p><strong>Requestable internal variables</strong></p><ul><li><code>cost</code>, the value of the cost.</li></ul><p><strong>Example</strong></p><pre><code class="language-none">@once cost(eleres,X,U,A,t) = eleres.Fh^2
ele1 = addelement!(model,ElementCost,[nod1],req=@request(Fh),
                   cost=cost,ElementType=AnchorLine,
                   Œõ‚Çòtop=[5.,0,0], x‚Çòbot=[250.,0], L=290., buoyancy=-5e3)</code></pre><p>See also: <a href="reference.html#Muscade.SingleDofCost"><code>SingleDofCost</code></a>, <a href="reference.html#Muscade.DofCost"><code>DofCost</code></a>, <a href="reference.html#Muscade.@request-Tuple{Any}"><code>@request</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L58-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.Hold" href="#Muscade.Hold"><code>Muscade.Hold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Hold &lt;: AbstractElement</code></pre><p>An element to set a single X-dof to zero.  </p><p><strong>Named arguments to the constructor</strong></p><ul><li><code>field::Symbol</code>. The field of the X-dof to constraint.</li><li><code>Œªfield::Symbol=Symbol(:Œª,field)</code>. The field of the Lagrange multiplier.</li></ul><p><strong>Example</strong></p><pre><code class="language-none">using Muscade
model = Model(:TestModel)
node  = addnode!(model,ùï£[0,0])
e     = addelement!(model,Hold,[node];field=:tx)</code></pre><p>See also: <a href="reference.html#Muscade.DofConstraint"><code>DofConstraint</code></a>, <a href="reference.html#Muscade.DofLoad"><code>DofLoad</code></a>, <a href="reference.html#Muscade.DofCost"><code>DofCost</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L348-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.Model" href="#Muscade.Model"><code>Muscade.Model</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">model = Model([ID=:my_model])</code></pre><p>Construct a blank <code>model</code>, which will be mutated to create a finite element [optimization] problem.</p><p>See also: <a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>addnode!</code></a>, <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>, <a href="reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>describe</code></a>, <a href="reference.html#Muscade.solve-Tuple{Any}"><code>solve</code></a>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ModelDescription.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.Node" href="#Muscade.Node"><code>Muscade.Node</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Node</code></pre><p>The eltype of vectors handed by Muscade as first argument to element constructors.</p><p>Example: <code>function SingleDofCost(nod::Vector{Node};class::Symbol, ... )</code></p><p>See also: <a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>coord</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ModelDescription.jl#L36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.QuickFix" href="#Muscade.QuickFix"><code>Muscade.QuickFix</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuickFix &lt;: AbstractElement</code></pre><p>An element for creating simple elements with &quot;one line&quot; of code.   Elements thus created have several limitations:</p><ul><li>no internal state.</li><li>no initialisation.</li><li>physical elements with only X-dofs.</li><li>only <code>R</code> can be espied.</li></ul><p>The element is intended for testing.  Muscade-based applications should not include this in their API. </p><p><strong>Named arguments to the constructor</strong></p><ul><li><code>inod::NTuple{Nx,ùï´}</code>. The element-node numbers of the X-dofs.</li><li><code>field::NTuple{Nx,Symbol}</code>. The fields of the X-dofs.</li><li><code>res::Function</code>, where <code>res(X::‚Ñù1,X‚Ä≤::‚Ñù1,X‚Ä≥::‚Ñù1,t::‚Ñù) ‚Üí ‚Ñù1</code>, the residual.</li></ul><p><strong>Examples</strong></p><p>A one-dimensional linear elastic spring with stiffness 2.</p><pre><code class="language-julia">using Muscade
model = Model(:TestModel)
node1  = addnode!(model,ùï£[0])
node2  = addnode!(model,ùï£[1])
e = addelement!(model,QuickFix,[node1,node2];inod=(1,2),field=(:tx1,:tx1),
                res=(X,X‚Ä≤,X‚Ä≥,t)-&gt;Svector{2}(2*(X[1]-X[2]),2*(X[2]-X[1])) )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L376-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.SingleDofCost" href="#Muscade.SingleDofCost"><code>Muscade.SingleDofCost</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SingleDofCost{Derivative,Class,Field,Tcost} &lt;: AbstractElement</code></pre><p>An element with a single node, for adding a cost to a given dof.  </p><p><strong>Named arguments to the constructor</strong></p><ul><li><code>class::Symbol</code>, either <code>:X</code>, <code>:U</code> or <code>:A</code>.</li><li><code>field::Symbol</code>.</li><li><code>cost::Function</code>, where <code>cost(x::‚Ñù,t::‚Ñù[,costargs...]) ‚Üí ‚Ñù</code>.</li><li><code>costargs::NTuple</code></li><li><code>derivative::Int</code> 0, 1 or 2 - which derivative of the dof enters the cost	    </li></ul><p><strong>Requestable internal variables</strong></p><ul><li><code>cost</code>, the value of the cost.</li></ul><p><strong>Example</strong></p><pre><code class="language-none">using Muscade
model = Model(:TestModel)
node  = addnode!(model,ùï£[0,0])
e     = addelement!(model,SingleDofCost,[node];class=:X,field=:tx,
                    costargs=(3.,),cost=(x,t,three)-&gt;(x/three)^2)</code></pre><p>See also: <a href="reference.html#Muscade.DofCost"><code>DofCost</code></a>, <a href="reference.html#Muscade.ElementCost"><code>ElementCost</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L105-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.StaticX" href="#Muscade.StaticX"><code>Muscade.StaticX</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StaticX</code></pre><p>A non-linear static solver for forward (not inverse, optimisation) FEM. The current implementation does not handle element memory. </p><p>An analysis is carried out by a call with the following syntax:</p><pre><code class="language-none">initialstate    = initialize!(model)
state           = solve(StaticX;initialstate=initialstate,time=[0.,1.])</code></pre><p><strong>Named arguments</strong></p><ul><li><code>dbg=(;)</code>           a named tuple to trace the call tree (for debugging)</li><li><code>verbose=true</code>      set to false to suppress printed output (for testing)</li><li><code>silenterror=false</code> set to true to suppress print out of error (for testing) </li><li><code>initialstate</code>      a single <code>state</code> - obtained from a call to <code>initialize!</code>, or                      from a previous analysis</li><li><code>time</code>              an <code>AbstractVector</code> vector of the times at which to compute the </li><li><code>maxiter=50</code>        maximum number of Newton-Raphson iteration at any given step </li><li><code>maxŒîx=1e-5</code>        convergence criteria: a norm on the scaled <code>X</code> increment </li><li><code>maxincrement=‚àû</code>    convergence criteria: a norm on the scaled residual</li><li><code>saveiter=false</code>    set to true so that the output <code>state</code> is a vector describing                      the states of the model at the last iteration (for debugging                      non-convergence) </li><li><code>Œ≥0=1.</code>             an initial value of the barrier coefficient for the handling of contact                     using an interior point method</li><li><code>Œ≥fac1=0.5</code>         at each iteration, the barrier parameter Œ≥ is multiplied </li><li><code>Œ≥fac2=100.</code>        by Œ≥fac1*exp(-min(Œ±·µ¢)/Œ≥fac2)^2), where Œ±·µ¢ is computed by the i-th                     interior point savvy element as Œ±·µ¢=abs(Œª-g)/Œ≥                                               </li></ul><p><strong>Output</strong></p><p>A vector of length equal to that of <code>time</code> containing the state of the model at each of these steps                       </p><p>See also: <a href="reference.html#Muscade.solve-Tuple{Any}"><code>solve</code></a>, <a href="reference.html#Muscade.StaticXUA"><code>StaticXUA</code></a>, <a href="reference.html#Muscade.initialize!-Tuple{Model}"><code>initialize!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/StaticX.jl#L40-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.StaticXUA" href="#Muscade.StaticXUA"><code>Muscade.StaticXUA</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StaticXUA</code></pre><p>A non-linear static solver for optimisation FEM. The current algorithm does not handle element memory. </p><p>An analysis is carried out by a call with the following syntax:</p><pre><code class="language-none">initialstate    = initialize!(model)
stateX          = solve(StaticX  ;initialstate=initialstate,time=[0.,1.])
stateXUA        = solve(StaticXUA;initialstate=stateX)</code></pre><p><strong>Named arguments</strong></p><ul><li><code>dbg=(;)</code>           a named tuple to trace the call tree (for debugging)</li><li><code>verbose=true</code>      set to false to suppress printed output (for testing)</li><li><code>silenterror=false</code> set to true to suppress print out of error (for testing) </li><li><code>initialstate</code>      a vector of <code>state</code>s, one for each load case in the optimization problem,                      obtained from one or several previous <code>StaticX</code> analyses</li><li><code>maxAiter=50</code>       maximum number of &quot;outer&quot; Newton-Raphson iterations over <code>A</code> </li><li><code>maxŒîa=1e-5</code>        &quot;outer&quot; convergence criteria: a norm on the scaled <code>A</code> increment </li><li><code>maxLa=‚àû</code>           &quot;outer&quot; convergence criteria: a norm on the scaled <code>La</code> residual</li><li><code>maxYiter=0</code>        maximum number of &quot;inner&quot; Newton-Raphson iterations over <code>X</code>                      and <code>U</code> for every value of <code>A</code>.  Experience so far is that these inner                     iterations do not increase performance, so the default is &quot;no inner                      iterations&quot;.   </li><li><code>maxŒîy=1e-5</code>        &quot;inner&quot; convergence criteria: a norm on the scaled <code>Y=[XU]</code> increment </li><li><code>maxLy=‚àû</code>           &quot;inner&quot; convergence criteria: a norm on the scaled <code>Ly=[Lx,Lu]</code> residual</li><li><code>saveiter=false</code>    set to true so that the output <code>state</code> is a vector describing                      the states of the model at the last iteration (for debugging                      non-convergence) </li><li><code>Œ≥0=1.</code>             an initial value of the barrier coefficient for the handling of contact                     using an interior point method</li><li><code>Œ≥fac1=0.5</code>         at each iteration, the barrier parameter Œ≥ is multiplied </li><li><code>Œ≥fac2=100.</code>        by Œ≥fac1*exp(-min(Œ±·µ¢)/Œ≥fac2)^2), where Œ±·µ¢ is computed by the i-th                     interior point savvy element as Œ±·µ¢=abs(Œª-g)/Œ≥                                               </li></ul><p><strong>Output</strong></p><p>A vector of length equal to that of <code>initialstate</code> containing the state of the optimized model at each of these steps                       </p><p>See also: <a href="reference.html#Muscade.solve-Tuple{Any}"><code>solve</code></a>, <a href="reference.html#Muscade.StaticX"><code>StaticX</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/StaticXUA.jl#L101-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.default" href="#Muscade.default"><code>Muscade.default</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">default{:fieldname}(namedtuple,defval)</code></pre><p>attempt to get a field <code>fieldname</code> from a <code>NamedTuple</code>. If <code>namedtuple</code> does not have  such a field - or is not a <code>NamedTuple</code>, return <code>defval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.‚Ñï" href="#Muscade.‚Ñï"><code>Muscade.‚Ñï</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">‚Ñï (\bbN)</code></pre><p>an alias for <code>UInt64</code>. For use in dispatching. <code>‚Ñï1</code>... <code>‚Ñï4</code> are <code>AbstractArrays</code> of dimensions 1 to 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.‚Ñù" href="#Muscade.‚Ñù"><code>Muscade.‚Ñù</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">‚Ñù (\bbR)</code></pre><p>an alias for abstract type <code>Real</code>. For use in dispatching. <code>‚Ñù1</code>... <code>‚Ñù4</code> are <code>AbstractArrays</code> of dimensions 1 to 4. <code>‚Ñù11</code> is an <code>AbstractVector</code> of <code>AbstractVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.‚Ñ§" href="#Muscade.‚Ñ§"><code>Muscade.‚Ñ§</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">‚Ñ§ (\bb‚Ñ§)</code></pre><p>an alias for abstract type <code>Integer</code>. For use in dispatching. <code>‚Ñ§1</code>... <code>‚Ñ§4</code> are <code>AbstractArrays</code> of dimensions 1 to 4. <code>‚Ñ§11</code> is an <code>AbstractVector</code> of <code>AbstractVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.ùîπ" href="#Muscade.ùîπ"><code>Muscade.ùîπ</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ùîπ (\bbB)</code></pre><p>an alias for <code>Bool</code>. For use in dispatching. <code>ùîπ1</code>... <code>ùîπ4</code> are <code>AbstractArrays</code> of dimensions 1 to 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.ùïì" href="#Muscade.ùïì"><code>Muscade.ùïì</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ùïì (\bbb)</code></pre><p>an alias for <code>Bool</code>. For use in <code>struct</code> definitions. <code>ùïì1</code>... <code>ùïì4</code> are <code>Arrays</code> of dimensions 1 to 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.ùïü" href="#Muscade.ùïü"><code>Muscade.ùïü</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ùïü (\bbn)</code></pre><p>an alias for <code>UInt64</code>. For use in <code>struct</code> definitions. <code>ùïü1</code>... <code>ùïü4</code> are <code>Arrays</code> of dimensions 1 to 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.ùï£" href="#Muscade.ùï£"><code>Muscade.ùï£</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ùï£ (\bbr)</code></pre><p>an alias for <code>Float64</code>. For use in <code>struct</code> definitions. <code>ùï£1</code>... <code>ùï£4</code> are <code>Arrays</code> of dimensions 1 to 4. <code>ùï£11</code> is a <code>Vector</code> of <code>Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.ùï´" href="#Muscade.ùï´"><code>Muscade.ùï´</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ùï´ (\bbz)</code></pre><p>an alias for <code>Int64</code>. For use in <code>struct</code> definitions. <code>ùï´1</code>... <code>ùï´4</code> are <code>Arrays</code> of dimensions 1 to 4. <code>ùï´11</code> is a <code>Vector</code> of <code>Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L56-L62">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement" href="#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>Muscade.addelement!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eleid = addelement!(model,ElType,nodid;kwargs...)</code></pre><p>Add one or several elements to <code>model</code>, connecting them to the nodes specified  by <code>nodid</code>.</p><p>If <code>nodid</code> is an <code>AbstractVector</code>: add a single element to the model. <code>eleid</code> is then a single element identifier.</p><p>If <code>nodid</code> is an <code>AbstractMatrix</code>: add multiple elements to the model. Each  column of <code>nodid</code> identifies the node of a single element. <code>eleid</code> is then  a vector of element identifiers.</p><p>For each element, <code>addelement!</code> will call <code>eleobj = ElType(nodes;kwargs...)</code> where <code>nodes</code> is a vector of nodes of the element.</p><p>See also: <a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>addnode!</code></a>, <a href="reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>describe</code></a>, <a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>coord</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ModelDescription.jl#L167-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}" href="#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>Muscade.addnode!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodid = addnode!(model,coord)</code></pre><p>If <code>coord</code> is an <code>AbstractVector</code> of <code>Real</code>: add a single node to the model.   Muscade does not prescribe what coordinate system to use.  Muscade will handle  to each element the <code>coord</code> of the nodes of the element, and the element  constructor must be able to make sense of it. <code>nodid</code> is a node identifier, that is used as input to <code>addelement!</code>.</p><p>If <code>coord</code> is an <code>AbstractMatrix</code>, its rows are treated as vectors of coordinates. <code>nodid</code> is then a vector of node identifiers.</p><p>See also: <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>, <a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>coord</code></a> , <a href="reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>describe</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ModelDescription.jl#L143-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.coord-Tuple{AbstractVector{Node}}" href="#Muscade.coord-Tuple{AbstractVector{Node}}"><code>Muscade.coord</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">c = coord(node)</code></pre><p>Used by element constructors to obtain the coordinates of a vector of Nodes handed by Muscade to the constructor. <code>c</code> is accessed as </p><pre><code class="language-none">c[inod][icoord]</code></pre><p>where <code>inod</code> is the element-node number and <code>icoord</code> an index into a vector of coordinates.</p><p>See also: <a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>addnode!</code></a>, <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>, <a href="reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>describe</code></a>, <a href="reference.html#Muscade.solve-Tuple{Any}"><code>solve</code></a>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ElementAPI.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.describe-Tuple{Model, Muscade.EleID}" href="#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>Muscade.describe</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">describe(model,spec)</code></pre><p>Print out information about <code>model</code>. <code>spec</code> can be an <code>EleID</code>, a <code>DofID</code>, a <code>NodID</code> to describe an element, a dof or a node. <code>spec</code> can be <code>:dof</code> to obtain a list of dofs or <code>:eletyp</code> for a list of element types.</p><p>See also: <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>, <a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>addnode!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ModelDescription.jl#L320-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.describe-Tuple{Muscade.State}" href="#Muscade.describe-Tuple{Muscade.State}"><code>Muscade.describe</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">describe(state;class=:all)</code></pre><p>Provide a description of the dofs stored in <code>state</code>. <code>class</code> can be either <code>:all</code>, <code>:Œõ</code>, <code>:ŒõX</code>, <code>:X</code>, <code>:U</code> or <code>:A</code></p><p>See also: <a href="reference.html#Muscade.solve-Tuple{Any}"><code>solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Output.jl#L148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.doflist-Union{Tuple{Type{E}}, Tuple{E}} where E&lt;:AbstractElement" href="#Muscade.doflist-Union{Tuple{Type{E}}, Tuple{E}} where E&lt;:AbstractElement"><code>Muscade.doflist</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Muscade.doflist(::Type{E&lt;:AbstractElement})</code></pre><p>Elements must overload Muscade&#39;s <code>doflist</code> function.   The method must take the element type as only input, and return a <code>NamedTuple</code> with fieldnames <code>inod</code>,<code>class</code> and <code>field</code>.  The tuple-fields are <code>NTuple</code>s of the same length.  For example</p><pre><code class="language-none">Muscade.doflist( ::Type{&lt;:Turbine}) = (inod =(1   ,1   ,2        ,2        ),
                                       class=(:X  ,:X  ,:A       ,:A       ),
                                       field=(:tx1,:tx2,:Œîseadrag,:Œîskydrag))</code></pre><p>In <code>Œõ</code>, <code>X</code>, <code>U</code> and <code>A</code> handed by Muscade to <code>residual</code> or <code>lagrangian</code>, the dofs in the vectors will follow the order in the doflist. Element developers are free to number their dofs by node, by field, or in any other way.</p><p>See also: <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>lagrangian</code></a>, <a href="reference.html#Muscade.residual-Tuple{}"><code>residual</code></a>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ElementAPI.jl#L76-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.equal-Tuple{Any}" href="#Muscade.equal-Tuple{Any}"><code>Muscade.equal</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">equal(t) ‚Üí :equal</code></pre><p>A function which for any value <code>t</code> returns the symbol <code>equal</code>.  Usefull for specifying the keyword argument <code>mode=equal</code> in adding an element of type `<code>DofConstraint</code> to a <code>Model</code>.</p><p>See also: <a href="reference.html#Muscade.DofConstraint"><code>DofConstraint</code></a>, <a href="reference.html#Muscade.off-Tuple{Any}"><code>off</code></a>, <a href="reference.html#Muscade.positive-Tuple{Any}"><code>positive</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L212-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.findlastassigned-Tuple{Vector}" href="#Muscade.findlastassigned-Tuple{Vector}"><code>Muscade.findlastassigned</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ilast = findlastassigned(state)</code></pre><p>Find the index <code>ilast</code> of the element before the first non assigment element in a vector <code>state</code>.</p><p>In multistep analyses, <code>solve</code> returns a vector <code>state</code> of length equal to the number of steps requested by the user.  If the analysis is aborted, <code>solve</code> still returns any available results at the begining of <code>state</code>, and the vector <code>state[1:ilast]</code> is fully assigned.</p><p>See also: <a href="reference.html#Muscade.solve-Tuple{Any}"><code>solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Output.jl#L173-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.getdof-Tuple{Muscade.State}" href="#Muscade.getdof-Tuple{Muscade.State}"><code>Muscade.getdof</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dofres = getdof(state;[class=:X],field=:somefield,nodID=[nodids...],[iders=0|1|2])</code></pre><p>Obtain the value of dofs of the same class and field, at various nodes and for various states.</p><p>If <code>state</code> is a vector, the output <code>dofres</code> has size <code>(ndof,nder+1,nstate)</code>. If <code>state</code> is a scalar, the output <code>dofres</code> has size <code>(ndof,nder+1)</code>.</p><p>See also: <a href="reference.html#Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S&lt;:Muscade.State"><code>getresult</code></a>, <a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>addnode!</code></a>, <a href="reference.html#Muscade.solve-Tuple{Any}"><code>solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Output.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.getndof-Tuple{DataType}" href="#Muscade.getndof-Tuple{DataType}"><code>Muscade.getndof</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getndof(model)
getndof(model,class)
getndof(model,(class1,class2,[,...]))</code></pre><p>where <code>class</code> can be any of <code>:X</code>, <code>:U</code>, <code>:A</code>: get the number of dofs in the specified classes (or in the whole model).</p><p><code>model</code> can be replaced with a concrete element type.  The number of dofs is then per element.</p><p>See also: <a href="reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>describe</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ModelDescription.jl#L94-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S&lt;:Muscade.State" href="#Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S&lt;:Muscade.State"><code>Muscade.getresult</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eleres = getresult(state,req,eleids)</code></pre><p>Obtain an array of nested NamedTuples and NTuples of element results. <code>req</code> is a request defined using <code>@request</code>. <code>state</code> a vector of <code>State</code>s or a single <code>State</code>. <code>eleids</code> can be either</p><ul><li>a vector of <code>EleID</code>s (obtained from <code>addelement!</code>) all corresponding to the same concrete element type</li><li>a concrete element type.</li></ul><p>If <code>state</code> is a vector, the output <code>dofres</code> has size <code>(nele,nstate)</code>. If <code>state</code> is a scalar, the output <code>dofres</code> has size <code>(nele)</code>.</p><p>See also: <a href="reference.html#Muscade.getdof-Tuple{Muscade.State}"><code>getdof</code></a>, <a href="reference.html#Muscade.@request-Tuple{Any}"><code>@request</code></a>, <a href="reference.html#Muscade.@espy-Tuple{Any}"><code>@espy</code></a>, <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>, <a href="reference.html#Muscade.solve-Tuple{Any}"><code>solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Output.jl#L50-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.initialize!-Tuple{Model}" href="#Muscade.initialize!-Tuple{Model}"><code>Muscade.initialize!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initialstate = initialize!(model)</code></pre><p>Finalize a model (invoquing <code>addnode!</code> and <code>addelement!</code> after <code>initialize!</code> will result in an error)  and return an initial <code>State</code> (with all dofs set to zero, as starting point for an analysis.)</p><p>See also: <a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>addnode!</code></a>, <a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>addelement!</code></a>, <a href="reference.html#Muscade.solve-Tuple{Any}"><code>solve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ModelDescription.jl#L294-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.lagrangian-Tuple{}" href="#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">@espy function Muscade.lagrangian(eleobj::MyElement,Œõ,X,U,A,t,œá,œácv,SP,dbg)
    ...
    return L,œá,FB
end</code></pre><p><strong>Inputs</strong></p><ul><li><code>eleobj</code> an element object</li><li><code>Œõ</code> a <code>SVector{nXdof,R} where{R&lt;:Real}</code>, Lagrange multipliers (aka <code>Œ¥X</code> virtual displacements).</li><li><code>X</code> a <code>NTuple</code> of <code>SVector{nXdof,R} where{R&lt;:Real}</code>, containing the Xdofs and, depending on the solver,  their time derivatives. Use <code>x=‚àÇ0(X)</code>, <code>v=‚àÇ1(X)</code> and <code>a=‚àÇ2(X)</code> to safely obtain vectors of zeros  where the solver leaves time derivatives undefined.</li><li><code>U</code> a <code>NTuple</code> of <code>SVector{nUdof,R} where{R&lt;:Real}</code>, containing the Udofs and, depending on the solver,  their time derivatives. Use <code>u=‚àÇ0(U)</code>, <code>Ãáu=‚àÇ1(U)</code> and <code>Ãàu=‚àÇ2(U)</code> to safely obtain vectors of zeros  where the solver leaves time derivatives undefined.</li><li><code>A</code> a <code>SVector{nAdof,R} where{R&lt;:Real}</code>.</li><li><code>t</code> a `<code>Real</code> containing the time.</li><li><code>œá</code> the element memory</li><li><code>œácv</code> a function used to built the updated element memory.</li><li><code>SP</code> solver parameters (for example: the barrier parameter <code>Œ≥</code> for  interior point methods).</li><li><code>dbg</code> a <code>NamedTuple</code> to be used <em>only</em> for debugging purposes.</li></ul><p><strong>Outputs</strong></p><ul><li><code>L</code> the lagrangian</li><li><code>œá</code> an updated element memory. Return <code>noœá</code> if the element has no memory.</li><li><code>FB</code> feedback from the element to the solver (for example: can <code>Œ≥</code> be  reduced?). Return <code>noFB</code> of the element has no feedback to provide.</li></ul><p>See also: <a href="reference.html#Muscade.residual-Tuple{}"><code>residual</code></a>, <a href="reference.html#Muscade.doflist-Union{Tuple{Type{E}}, Tuple{E}} where E&lt;:AbstractElement"><code>doflist</code></a>, <a href="reference.html#Muscade.@espy-Tuple{Any}"><code>@espy</code></a>, <a href="reference.html#Muscade.‚àÇ0-Tuple{Any}"><code>‚àÇ0</code></a>, <a href="reference.html#Muscade.‚àÇ1-Tuple{Any}"><code>‚àÇ1</code></a>, <a href="reference.html#Muscade.‚àÇ2-Tuple{Any}"><code>‚àÇ2</code></a>, <a href="reference.html#Muscade.noœá"><code>noœá</code></a>, <a href="reference.html#Muscade.noFB"><code>noFB</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ElementAPI.jl#L96-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.muscadeerror-Tuple{NamedTuple, Any}" href="#Muscade.muscadeerror-Tuple{NamedTuple, Any}"><code>Muscade.muscadeerror</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">muscadeerror([[dbg,]msg])</code></pre><p>Throw a <code>MuscadeException</code>, where</p><ul><li><code>dbg</code> is a <code>NamedTuple</code> that contains &quot;location information&quot;</li></ul><p>(for example: solver, step, iteration, element, quadrature point) that will be displayed with the error message.</p><ul><li><code>msg</code> is a <code>String</code> describing the problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Exceptions.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.off-Tuple{Any}" href="#Muscade.off-Tuple{Any}"><code>Muscade.off</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">off(t) ‚Üí :off</code></pre><p>A function which for any value <code>t</code> returns the symbol <code>off</code>.  Usefull for specifying the keyword argument <code>mode=off</code> in adding an element of type `<code>DofConstraint</code> to a <code>Model</code>.</p><pre><code class="language-none">See also: [`DofConstraint`](@ref), [`equal`](@ref), [`positive`](@ref)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L202-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.positive-Tuple{Any}" href="#Muscade.positive-Tuple{Any}"><code>Muscade.positive</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">positive(t) ‚Üí :positive</code></pre><p>A function which for any value <code>t</code> returns the symbol <code>positive</code>.  Usefull for specifying the keyword argument <code>mode=positive</code> in adding an element of type `<code>DofConstraint</code> to a <code>Model</code>.</p><p>See also: <a href="reference.html#Muscade.DofConstraint"><code>DofConstraint</code></a>, <a href="reference.html#Muscade.off-Tuple{Any}"><code>off</code></a>, <a href="reference.html#Muscade.equal-Tuple{Any}"><code>equal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/BasicElements.jl#L222-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.residual-Tuple{}" href="#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>@espy function Muscade.residual(eleobj::MyElement,X,U,A,t,œá,œácv,SP,dbg)     ...     return R,œá,FB end</p><p>The inputs and outputs to <code>residual</code> are the same as for <code>lagrangian</code> with two exceptions:</p><ul><li><code>residual</code> does no have input <code>Œõ</code>.</li><li>the first output argument of <code>residual</code> is not a Lagrangian <code>L</code> but <code>R</code>,</li></ul><p>a <code>SVector{nXdof,R} where{R&lt;:Real}</code>, containing the element&#39;s contribution   to the residual of the equations to be solved.     </p><p>See <a href="reference.html#Muscade.lagrangian-Tuple{}"><code>lagrangian</code></a> for the rest of the inputs and outputs. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ElementAPI.jl#L129-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.setscale!-Tuple{Model}" href="#Muscade.setscale!-Tuple{Model}"><code>Muscade.setscale!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setscale!(model;scale=nothing,Œõscale=nothing)</code></pre><p>Provides an order of magnitude for each type of dof in the model.   This is usued to improve the conditioning of the incremental problems and for convergence criteria. <code>scale</code> is a <code>NamedTuple</code> with fieldnames within  <code>X</code>, <code>U</code> and <code>A</code>.  Each field is itself a <code>NamedTuple</code> with fieldnames being dof fields, and value being the expected order of magnitude.</p><p>For example <code>scale = (X=(tx=10,rx=1),A=(drag=3.))</code> should be read as: X-dofs of field <code>:tx</code> are in tens of meters, <code>:rx</code> are in radians, and A-dofs of  field <code>drag</code> are of the order of 3. All other degrees of freedom are expected  to be roughly of the order of 1.</p><p><code>Œõscale</code> is a scalar. The scale of a Œõ-dof will be deemed to be the scale of the  corresponding X-dof, times <code>Œõscale</code>.</p><p>See also: <a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>addnode!</code></a>, <a href="reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>describe</code></a>, <a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>coord</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ModelDescription.jl#L260-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.solve-Tuple{Any}" href="#Muscade.solve-Tuple{Any}"><code>Muscade.solve</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(Solver;dbg=(;),verbose=true,silenterror=false,kwargs...)</code></pre><p>Execute an analysis using <code>Solver</code>, and safeguard partial results in the case of error. </p><p><strong>Named arguments</strong></p><ul><li><code>dbg=(;)</code>           a named tuple to trace the call tree (for debugging)</li><li><code>verbose=true</code>      set to false to suppress printed output (for testing)</li><li><code>silenterror=false</code> set to true to suppress print out of error (for testing) </li><li><code>kwargs...</code>         Further arguments passed on to the method <code>solve</code> provided by the solver</li></ul><p>This will call the method <code>solve</code> provided by the solver with <code>solve(Solver,pstate,verbose,(dbg...,solver=Symbol(Solver));kwargs...)</code></p><p>See also: <a href="reference.html#Muscade.StaticX"><code>StaticX</code></a>, <a href="reference.html#Muscade.StaticXUA"><code>StaticXUA</code></a>, <a href="reference.html#Muscade.initialize!-Tuple{Model}"><code>initialize!</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Solve.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.toggle-Union{Tuple{Tb}, Tuple{Ta}, Tuple{Bool, Ta, Tb}} where {Ta, Tb}" href="#Muscade.toggle-Union{Tuple{Tb}, Tuple{Ta}, Tuple{Bool, Ta, Tb}} where {Ta, Tb}"><code>Muscade.toggle</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">toggle(condition,a,b)</code></pre><p>Typestable equivalent of <code>condition ? a : b</code>.   Returns a value converted to <code>promote_type(typeof(a),typeof(b))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L115-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.‚àÇ0-Tuple{Any}" href="#Muscade.‚àÇ0-Tuple{Any}"><code>Muscade.‚àÇ0</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">position = ‚àÇ0(X)</code></pre><p>Used by elements&#39; <code>residual</code> or <code>lagrangian</code> to extract the zero-th order time derivative from the variables <code>X</code> and <code>U</code>.</p><p>See also: <a href="reference.html#Muscade.‚àÇ1-Tuple{Any}"><code>‚àÇ1</code></a>,<a href="reference.html#Muscade.‚àÇ2-Tuple{Any}"><code>‚àÇ2</code></a>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ElementAPI.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.‚àÇ1-Tuple{Any}" href="#Muscade.‚àÇ1-Tuple{Any}"><code>Muscade.‚àÇ1</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">velocity = ‚àÇ1(X)</code></pre><p>Used by elements&#39; <code>residual</code> or <code>lagrangian</code> to extract the first order time derivative from the variables <code>X</code> and <code>U</code>. Where the solver does not provide this derivative (e.g. a static solver), the output is a vector of zeros.</p><p>See also: <a href="reference.html#Muscade.‚àÇ0-Tuple{Any}"><code>‚àÇ0</code></a>,<a href="reference.html#Muscade.‚àÇ2-Tuple{Any}"><code>‚àÇ2</code></a>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ElementAPI.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.‚àÇ2-Tuple{Any}" href="#Muscade.‚àÇ2-Tuple{Any}"><code>Muscade.‚àÇ2</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">position = ‚àÇ2(X)</code></pre><p>Used by elements&#39; <code>residual</code> or <code>lagrangian</code> to extract the zero-th order time derivative from the variables <code>X</code> and <code>U</code>. Where the solver does not provide this derivative (e.g. a static solver), the output is a vector of zeros.</p><p>See also: <a href="reference.html#Muscade.‚àÇ0-Tuple{Any}"><code>‚àÇ0</code></a>,<a href="reference.html#Muscade.‚àÇ1-Tuple{Any}"><code>‚àÇ1</code></a>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/ElementAPI.jl#L49-L57">source</a></section></article><h2 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Muscade.@espy-Tuple{Any}" href="#Muscade.@espy-Tuple{Any}"><code>Muscade.@espy</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@espy function ... end</code></pre><p>From an anotated function code, generate     - &quot;clean&quot; code, in which the anotations have been deleted, and with        the call syntax <code>argout... = foo(argin...)</code>     - &quot;espying&quot; code, with added input and ouput arguments       <code>argout...,res = foo(argin...,req)</code> where <code>req</code> has been       generated using <code>@request</code> and <code>res</code> is a nested structure       of <code>NamedTuple</code>s and <code>NTuple</code>s containing the requested data.</p><p>The macro is not general: it is designed for <code>residual</code> and <code>lagrangian</code>, which for performance have to be programmed in &quot;immutable&quot; style: they must never mutate variables (this implies in particular, no adding into an array in a loop over Gauss points). So @espy only supports the specific programming constructs needed in this style.</p><p>The following is an example of anotated code:</p><pre><code class="language-none">@espy function residual(x::Vector{R},y) where{R&lt;:Real}
    ngp=2
    accum = ntuple(ngp) do igp
        ‚òºz = x[igp]+y[igp]
        ‚òºs,‚òºt  = ‚òºmaterial(z)
        ‚ô¢square = s^2
        @named(s) 
    end
    r = sum(i-&gt;accum[i].s,ngp)
    return r,nothing,nothing
end</code></pre><ul><li>The keyword <code>function</code> is preceded by the macro-call <code>@espy</code>.  </li><li>The name of requestable variables of interest is preceded by <code>‚òº</code> (<code>\sun</code>).  Such anotation must always appear on the left of an assigment. </li><li>If the name of a variable is preceded by <code>‚ô¢</code> (<code>\diamond</code>), then the variable is evaluated only if requested. Such a notation can only be used if there is only one variable left of the assignement.</li><li>The name of a function being called must be preceded by <code>‚òº</code> if the definition of the function is itself preceeded by the macro-call <code>@espy</code>.</li><li><code>for</code>-loops are not supported. <code>do</code>-loops must be used: to be efficient,  <code>residual</code> and <code>lagrangian</code> must not allocate and thus use immutables.</li></ul><p>See also: <a href="reference.html#Muscade.@request-Tuple{Any}"><code>@request</code></a>, <a href="reference.html#Muscade.@espydbg-Tuple{Any}"><code>@espydbg</code></a>, <a href="reference.html#Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S&lt;:Muscade.State"><code>getresult</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Espy.jl#L284-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.@espydbg-Tuple{Any}" href="#Muscade.@espydbg-Tuple{Any}"><code>Muscade.@espydbg</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@espydbg function ... end</code></pre><p>Generate the same code as <a href="reference.html#Muscade.@espy-Tuple{Any}"><code>@espy</code></a> and print it (for debug purposes).</p><p>See also: <a href="reference.html#Muscade.@espy-Tuple{Any}"><code>@espy</code></a>, <a href="reference.html#Muscade.@request-Tuple{Any}"><code>@request</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Espy.jl#L338-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.@once-Tuple{Any}" href="#Muscade.@once-Tuple{Any}"><code>Muscade.@once</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@once f(x)= x^2</code></pre><p>do not parse the definition of function <code>f</code> again if not modified. Using in a script, this prevents recompilations in <code>Muscade</code> or applications based on it when they receive such functions as argument</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Dialect.jl#L178-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Muscade.@request-Tuple{Any}" href="#Muscade.@request-Tuple{Any}"><code>Muscade.@request</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">req = @request expr</code></pre><p>Create a request of internal results wanted from a function. Considering the function presented as example for <a href="reference.html#Muscade.@espy-Tuple{Any}"><code>@espy</code></a>, examples of possible syntax include</p><pre><code class="language-none">req       = @request gp(s,z,material(a,b))
req       = @request gp(s)
req       = @request gp(material(a))</code></pre><p>The first expression can be read as follows: &quot;In the function, there is a <code>do</code> loop over variable <code>igp</code>, and within this loop a call to a function <code>material</code>.  Results <code>s</code> and <code>z</code> are wanted from within the loop, and results <code>a</code> and <code>b</code> from within <code>material</code>.</p><p>The corresponding datastructure containing the results for each element is a nesting of <code>NTuples</code> and <code>NamedTuples</code>,  and can be accessed as <code>out.gp[igp].material.a</code> and so forth.        </p><p>See also: <a href="reference.html#Muscade.@espy-Tuple{Any}"><code>@espy</code></a>, <a href="reference.html#Muscade.@espydbg-Tuple{Any}"><code>@espydbg</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SINTEF/Muscade.jl/blob/aa213dcb814ed78c9595638ca068dfc16cd6339d/src/Espy.jl#L27-L48">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="reference.html#Muscade.noFB"><code>Muscade.noFB</code></a></li><li><a href="reference.html#Muscade.noœá"><code>Muscade.noœá</code></a></li><li><a href="reference.html#Muscade.œµ"><code>Muscade.œµ</code></a></li><li><a href="reference.html#Muscade.‚àû"><code>Muscade.‚àû</code></a></li><li><a href="reference.html#Muscade.AbstractElement"><code>Muscade.AbstractElement</code></a></li><li><a href="reference.html#Muscade.DofConstraint"><code>Muscade.DofConstraint</code></a></li><li><a href="reference.html#Muscade.DofCost"><code>Muscade.DofCost</code></a></li><li><a href="reference.html#Muscade.DofLoad"><code>Muscade.DofLoad</code></a></li><li><a href="reference.html#Muscade.ElementCost"><code>Muscade.ElementCost</code></a></li><li><a href="reference.html#Muscade.Hold"><code>Muscade.Hold</code></a></li><li><a href="reference.html#Muscade.Model"><code>Muscade.Model</code></a></li><li><a href="reference.html#Muscade.Node"><code>Muscade.Node</code></a></li><li><a href="reference.html#Muscade.QuickFix"><code>Muscade.QuickFix</code></a></li><li><a href="reference.html#Muscade.SingleDofCost"><code>Muscade.SingleDofCost</code></a></li><li><a href="reference.html#Muscade.StaticX"><code>Muscade.StaticX</code></a></li><li><a href="reference.html#Muscade.StaticXUA"><code>Muscade.StaticXUA</code></a></li><li><a href="reference.html#Muscade.default"><code>Muscade.default</code></a></li><li><a href="reference.html#Muscade.‚Ñï"><code>Muscade.‚Ñï</code></a></li><li><a href="reference.html#Muscade.‚Ñù"><code>Muscade.‚Ñù</code></a></li><li><a href="reference.html#Muscade.‚Ñ§"><code>Muscade.‚Ñ§</code></a></li><li><a href="reference.html#Muscade.ùîπ"><code>Muscade.ùîπ</code></a></li><li><a href="reference.html#Muscade.ùïì"><code>Muscade.ùïì</code></a></li><li><a href="reference.html#Muscade.ùïü"><code>Muscade.ùïü</code></a></li><li><a href="reference.html#Muscade.ùï£"><code>Muscade.ùï£</code></a></li><li><a href="reference.html#Muscade.ùï´"><code>Muscade.ùï´</code></a></li><li><a href="reference.html#Muscade.addelement!-Union{Tuple{T}, Tuple{Model, Type{T}, Matrix{Muscade.NodID}}} where T&lt;:AbstractElement"><code>Muscade.addelement!</code></a></li><li><a href="reference.html#Muscade.addnode!-Tuple{Model, AbstractMatrix{t} where t&lt;:Real}"><code>Muscade.addnode!</code></a></li><li><a href="reference.html#Muscade.coord-Tuple{AbstractVector{Node}}"><code>Muscade.coord</code></a></li><li><a href="reference.html#Muscade.describe-Tuple{Model, Muscade.EleID}"><code>Muscade.describe</code></a></li><li><a href="reference.html#Muscade.describe-Tuple{Muscade.State}"><code>Muscade.describe</code></a></li><li><a href="reference.html#Muscade.doflist-Union{Tuple{Type{E}}, Tuple{E}} where E&lt;:AbstractElement"><code>Muscade.doflist</code></a></li><li><a href="reference.html#Muscade.equal-Tuple{Any}"><code>Muscade.equal</code></a></li><li><a href="reference.html#Muscade.findlastassigned-Tuple{Vector}"><code>Muscade.findlastassigned</code></a></li><li><a href="reference.html#Muscade.getdof-Tuple{Muscade.State}"><code>Muscade.getdof</code></a></li><li><a href="reference.html#Muscade.getndof-Tuple{DataType}"><code>Muscade.getndof</code></a></li><li><a href="reference.html#Muscade.getresult-Union{Tuple{S}, Tuple{Vector{S}, Any, Vector{Muscade.EleID}}} where S&lt;:Muscade.State"><code>Muscade.getresult</code></a></li><li><a href="reference.html#Muscade.initialize!-Tuple{Model}"><code>Muscade.initialize!</code></a></li><li><a href="reference.html#Muscade.lagrangian-Tuple{}"><code>Muscade.lagrangian</code></a></li><li><a href="reference.html#Muscade.muscadeerror-Tuple{NamedTuple, Any}"><code>Muscade.muscadeerror</code></a></li><li><a href="reference.html#Muscade.off-Tuple{Any}"><code>Muscade.off</code></a></li><li><a href="reference.html#Muscade.positive-Tuple{Any}"><code>Muscade.positive</code></a></li><li><a href="reference.html#Muscade.residual-Tuple{}"><code>Muscade.residual</code></a></li><li><a href="reference.html#Muscade.setscale!-Tuple{Model}"><code>Muscade.setscale!</code></a></li><li><a href="reference.html#Muscade.solve-Tuple{Any}"><code>Muscade.solve</code></a></li><li><a href="reference.html#Muscade.toggle-Union{Tuple{Tb}, Tuple{Ta}, Tuple{Bool, Ta, Tb}} where {Ta, Tb}"><code>Muscade.toggle</code></a></li><li><a href="reference.html#Muscade.‚àÇ0-Tuple{Any}"><code>Muscade.‚àÇ0</code></a></li><li><a href="reference.html#Muscade.‚àÇ1-Tuple{Any}"><code>Muscade.‚àÇ1</code></a></li><li><a href="reference.html#Muscade.‚àÇ2-Tuple{Any}"><code>Muscade.‚àÇ2</code></a></li><li><a href="reference.html#Muscade.@espy-Tuple{Any}"><code>Muscade.@espy</code></a></li><li><a href="reference.html#Muscade.@espydbg-Tuple{Any}"><code>Muscade.@espydbg</code></a></li><li><a href="reference.html#Muscade.@once-Tuple{Any}"><code>Muscade.@once</code></a></li><li><a href="reference.html#Muscade.@request-Tuple{Any}"><code>Muscade.@request</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Adiff.html">¬´ Automatic differentiation</a><a class="docs-footer-nextpage" href="LICENSE.html">MIT License ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 May 2023 12:26">Friday 5 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
